# -*- coding: utf-8 -*-
"""Untitled12.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1LEdczNJoRCoxsCbD43p-UKwOyITfXK6U
"""

import mlrose_hiive as mlrose
import numpy as np
import random
import matplotlib.pyplot as plt

# Define the distance matrix
def create_distance_matrix(num_cities):
    np.random.seed(42)
    coords = np.random.rand(num_cities, 2)
    dist_matrix = np.linalg.norm(coords[:, np.newaxis] - coords, axis=2)
    return dist_matrix

# Define the fitness function
def tsp_fitness(route, dist_matrix):
    total_distance = sum(dist_matrix[route[i], route[i + 1]] for i in range(len(route) - 1))
    total_distance += dist_matrix[route[-1], route[0]]  # return to start
    return total_distance

def swap_two_cities(route):
    new_route = route.copy()
    i, j = random.sample(range(len(route)), 2)
    new_route[i], new_route[j] = new_route[j], new_route[i]
    return new_route

def hill_climbing_tsp(dist_matrix, max_iterations, seed):
    np.random.seed(seed)
    random.seed(seed)

    num_cities = len(dist_matrix)
    current_route = list(range(num_cities))
    random.shuffle(current_route)
    current_fitness = tsp_fitness(current_route, dist_matrix)

    fitness_history = [current_fitness]

    for _ in range(max_iterations):
        new_route = swap_two_cities(current_route)
        new_fitness = tsp_fitness(new_route, dist_matrix)

        if new_fitness > current_fitness:
            current_route = new_route
            current_fitness = new_fitness

        fitness_history.append(current_fitness)

    return current_route, current_fitness, fitness_history

def run_experiments(num_cities, max_iterations, num_runs, seeds):
    all_fitness_histories = []
    dist_matrix = create_distance_matrix(num_cities)

    for seed in seeds:
        _, _, fitness_history = hill_climbing_tsp(dist_matrix, max_iterations, seed)
        all_fitness_histories.append(fitness_history)

    return np.array(all_fitness_histories)

def plot_best_fitness(fitness_histories):
    best_fitness = np.max(fitness_histories, axis=0)
    avg_fitness = np.mean(fitness_histories, axis=0)
    std_fitness = np.std(fitness_histories, axis=0)

    plt.figure(figsize=(10, 6))
    plt.step(range(len(best_fitness)), best_fitness, label='Best Fitness', where='post')
    plt.fill_between(range(len(avg_fitness)), avg_fitness - std_fitness, avg_fitness + std_fitness, alpha=0.2, label='Variance', step='post')
    plt.xlabel('Iteration')
    plt.ylabel('Fitness (Total Distance)')
    plt.title('RHC - Best Fitness (Total Distance) vs. Iteration with Variance')
    plt.legend()
    plt.grid(True)
    plt.show()

# Parameters
num_cities = 100  # Number of cities
max_iterations = 5000  # Maximum number of iterations
num_runs = 50  # Number of runs
seeds = [i for i in range(num_runs)]  # Generate N seeds

# Run experiments
all_fitness_histories = run_experiments(num_cities, max_iterations, num_runs, seeds)

# Plot best fitness
plot_best_fitness(all_fitness_histories)

import mlrose_hiive as mlrose
import numpy as np
import random
import matplotlib.pyplot as plt

# Define the distance matrix
def create_distance_matrix(num_cities):
    np.random.seed(42)
    coords = np.random.rand(num_cities, 2)
    dist_matrix = np.linalg.norm(coords[:, np.newaxis] - coords, axis=2)
    return dist_matrix

# Define the fitness function
def tsp_fitness(route, dist_matrix):
    total_distance = sum(dist_matrix[route[i], route[i + 1]] for i in range(len(route) - 1))
    total_distance += dist_matrix[route[-1], route[0]]  # return to start
    return total_distance

# Swap two cities in the route
def swap_two_cities(route):
    new_route = route.copy()
    i, j = random.sample(range(len(route)), 2)
    new_route[i], new_route[j] = new_route[j], new_route[i]
    return new_route

# Simulated Annealing algorithm for TSP
def simulated_annealing_tsp(dist_matrix, max_iterations, seed, initial_temp, cooling_rate):
    np.random.seed(seed)
    random.seed(seed)

    num_cities = len(dist_matrix)
    current_route = list(range(num_cities))
    random.shuffle(current_route)
    current_fitness = tsp_fitness(current_route, dist_matrix)
    best_route = current_route
    best_fitness = current_fitness

    fitness_history = [current_fitness]
    temperature = initial_temp

    for _ in range(max_iterations):
        new_route = swap_two_cities(current_route)
        new_fitness = tsp_fitness(new_route, dist_matrix)
        delta_fitness = new_fitness - current_fitness

        if delta_fitness > 0 or random.random() < np.exp(delta_fitness / temperature):
            current_route = new_route
            current_fitness = new_fitness

            if new_fitness > best_fitness:
                best_route = new_route
                best_fitness = new_fitness

        fitness_history.append(current_fitness)
        temperature *= cooling_rate

    return best_route, best_fitness, fitness_history

# Run experiments with multiple seeds
def run_experiments(num_cities, max_iterations, num_runs, seeds, initial_temp, cooling_rate):
    all_fitness_histories = []
    dist_matrix = create_distance_matrix(num_cities)

    for seed in seeds:
        _, _, fitness_history = simulated_annealing_tsp(dist_matrix, max_iterations, seed, initial_temp, cooling_rate)
        all_fitness_histories.append(fitness_history)

    return np.array(all_fitness_histories)

# Plot the best fitness with variance
def plot_best_fitness(fitness_histories, title):
    best_fitness = np.max(fitness_histories, axis=0)
    avg_fitness = np.mean(fitness_histories, axis=0)
    std_fitness = np.std(fitness_histories, axis=0)

    plt.figure(figsize=(10, 6))
    plt.step(range(len(best_fitness)), best_fitness, label='Best Fitness', where='post')
    plt.fill_between(range(len(avg_fitness)), avg_fitness - std_fitness, avg_fitness + std_fitness, alpha=0.2, label='Variance', step='post')
    plt.xlabel('Iteration')
    plt.ylabel('Fitness (Total Distance)')
    plt.title(title)
    plt.legend()
    plt.grid(True)
    plt.show()

# Parameters for tuning
num_cities = 100  # Number of cities
max_iterations = 5000  # Maximum number of iterations
num_runs = 50  # Number of runs
seeds = [i for i in range(num_runs)]  # Generate N seeds

# Different parameters to test
parameter_sets = [
    {'initial_temp': 1000, 'cooling_rate': 0.995},
    {'initial_temp': 500, 'cooling_rate': 0.99},
    {'initial_temp': 2000, 'cooling_rate': 0.998},
    {'initial_temp': 1000, 'cooling_rate': 0.99},
    {'initial_temp': 1500, 'cooling_rate': 0.995},
]

# Run experiments for each parameter set
for params in parameter_sets:
    initial_temp = params['initial_temp']
    cooling_rate = params['cooling_rate']
    fitness_histories = run_experiments(num_cities, max_iterations, num_runs, seeds, initial_temp, cooling_rate)
    plot_best_fitness(fitness_histories, f'Best Fitness (Initial Temp: {initial_temp}, Cooling Rate: {cooling_rate})')

import mlrose_hiive as mlrose
import numpy as np
import random
import matplotlib.pyplot as plt

# Define the distance matrix
def create_distance_matrix(num_cities):
    np.random.seed(42)
    coords = np.random.rand(num_cities, 2)
    dist_matrix = np.linalg.norm(coords[:, np.newaxis] - coords, axis=2)
    return dist_matrix

# Convert the distance matrix to a list of tuples for mlrose compatibility
def distance_list(dist_matrix):
    num_cities = len(dist_matrix)
    distances = []
    for i in range(num_cities):
        for j in range(i + 1, num_cities):
            distances.append((i, j, dist_matrix[i, j]))
    return distances

# Define the fitness function
def tsp_fitness(route, dist_matrix):
    total_distance = sum(dist_matrix[route[i], route[i + 1]] for i in range(len(route) - 1))
    total_distance += dist_matrix[route[-1], route[0]]  # return to start
    return total_distance

# Swap two cities in the route
def swap_two_cities(route):
    new_route = route.copy()
    i, j = random.sample(range(len(route)), 2)
    new_route[i], new_route[j] = new_route[j], new_route[i]
    return new_route

# Simulated Annealing algorithm for TSP
def simulated_annealing_tsp(dist_matrix, max_iterations, seed, initial_temp, cooling_rate):
    np.random.seed(seed)
    random.seed(seed)

    num_cities = len(dist_matrix)
    current_route = list(range(num_cities))
    random.shuffle(current_route)
    current_fitness = tsp_fitness(current_route, dist_matrix)
    best_route = current_route
    best_fitness = current_fitness

    fitness_history = [current_fitness]
    temperature = initial_temp

    for _ in range(max_iterations):
        new_route = swap_two_cities(current_route)
        new_fitness = tsp_fitness(new_route, dist_matrix)
        delta_fitness = new_fitness - current_fitness

        if delta_fitness > 0 or random.random() < np.exp(delta_fitness / temperature):
            current_route = new_route
            current_fitness = new_fitness

            if new_fitness > best_fitness:
                best_route = new_route
                best_fitness = new_fitness

        fitness_history.append(current_fitness)
        temperature *= cooling_rate

    return best_route, best_fitness, fitness_history

# Run experiments with multiple seeds
def run_experiments(num_cities, max_iterations, num_runs, seeds, initial_temp, cooling_rate):
    all_fitness_histories = []
    dist_matrix = create_distance_matrix(num_cities)
    distances = distance_list(dist_matrix)

    for seed in seeds:
        _, _, fitness_history = simulated_annealing_tsp(dist_matrix, max_iterations, seed, initial_temp, cooling_rate)
        all_fitness_histories.append(fitness_history)

    return np.array(all_fitness_histories)

# Plot the best fitness with variance
def plot_best_fitness(fitness_histories):
    best_fitness = np.max(fitness_histories, axis=0)
    avg_fitness = np.mean(fitness_histories, axis=0)
    std_fitness = np.std(fitness_histories, axis=0)

    plt.figure(figsize=(10, 6))
    plt.step(range(len(best_fitness)), best_fitness, label='Best Fitness', where='post')
    plt.fill_between(range(len(avg_fitness)), avg_fitness - std_fitness, avg_fitness + std_fitness, alpha=0.2, label='Variance', step='post')
    plt.xlabel('Iteration')
    plt.ylabel('Fitness (Total Distance)')
    plt.title('SA - Best Fitness (Total Distance) vs. Iteration with Variance')
    plt.legend()
    plt.grid(True)
    plt.show()

# Parameters
num_cities = 100  # Number of cities
max_iterations = 5000  # Maximum number of iterations
num_runs = 50  # Number of runs
seeds = [i for i in range(num_runs)]  # Generate N seeds
initial_temp = 500  # Initial temperature
cooling_rate = 0.99  # Cooling rate

# Run experiments
all_fitness_histories = run_experiments(num_cities, max_iterations, num_runs, seeds, initial_temp, cooling_rate)

# Plot best fitness
plot_best_fitness(all_fitness_histories)

import mlrose_hiive as mlrose
import numpy as np
import random
import matplotlib.pyplot as plt

# Define the distance matrix
def create_distance_matrix(num_cities):
    np.random.seed(42)
    coords = np.random.rand(num_cities, 2)
    dist_matrix = np.linalg.norm(coords[:, np.newaxis] - coords, axis=2)
    return dist_matrix

# Define the fitness function
def tsp_fitness(route, dist_matrix):
    total_distance = sum(dist_matrix[route[i], route[i + 1]] for i in range(len(route) - 1))
    total_distance += dist_matrix[route[-1], route[0]]  # return to start
    return total_distance

# Swap two cities in the route
def swap_two_cities(route):
    new_route = route.copy()
    i, j = random.sample(range(len(route)), 2)
    new_route[i], new_route[j] = new_route[j], new_route[i]
    return new_route

# Simulated Annealing algorithm for TSP
def simulated_annealing_tsp(dist_matrix, max_iterations, seed, initial_temp, cooling_rate):
    np.random.seed(seed)
    random.seed(seed)

    num_cities = len(dist_matrix)
    current_route = list(range(num_cities))
    random.shuffle(current_route)
    current_fitness = tsp_fitness(current_route, dist_matrix)
    best_route = current_route
    best_fitness = current_fitness

    fitness_history = [current_fitness]
    temperature = initial_temp

    for _ in range(max_iterations):
        new_route = swap_two_cities(current_route)
        new_fitness = tsp_fitness(new_route, dist_matrix)
        delta_fitness = new_fitness - current_fitness

        if delta_fitness > 0 or random.random() < np.exp(delta_fitness / temperature):
            current_route = new_route
            current_fitness = new_fitness

            if new_fitness > best_fitness:
                best_route = new_route
                best_fitness = new_fitness

        fitness_history.append(current_fitness)
        temperature *= cooling_rate

    return best_route, best_fitness, fitness_history

# Run experiments with multiple seeds
def run_experiments(num_cities, max_iterations, num_runs, seeds, initial_temp, cooling_rate):
    all_fitness_histories = []
    dist_matrix = create_distance_matrix(num_cities)

    for seed in seeds:
        _, _, fitness_history = simulated_annealing_tsp(dist_matrix, max_iterations, seed, initial_temp, cooling_rate)
        all_fitness_histories.append(fitness_history)

    return np.array(all_fitness_histories)

# Plot fitness vs. iteration for different initial temperatures
def plot_fitness_vs_iteration_initial_temp(initial_temps, num_cities, max_iterations, num_runs, seeds, cooling_rate):
    plt.figure(figsize=(10, 6))
    for initial_temp in initial_temps:
        fitness_histories = run_experiments(num_cities, max_iterations, num_runs, seeds, initial_temp, cooling_rate)
        avg_fitness = np.mean(fitness_histories, axis=0)
        plt.plot(avg_fitness, label=f'Initial Temp: {initial_temp}')

    plt.xlabel('Iteration')
    plt.ylabel('Fitness (Total Distance)')
    plt.title('Fitness vs. Iteration for Different Initial Temperatures')
    plt.legend()
    plt.grid(True)
    plt.show()

# Plot fitness vs. iteration for different cooling rates
def plot_fitness_vs_iteration_cooling_rate(cooling_rates, num_cities, max_iterations, num_runs, seeds, initial_temp):
    plt.figure(figsize=(10, 6))
    for cooling_rate in cooling_rates:
        fitness_histories = run_experiments(num_cities, max_iterations, num_runs, seeds, initial_temp, cooling_rate)
        avg_fitness = np.mean(fitness_histories, axis=0)
        plt.plot(avg_fitness, label=f'Cooling Rate: {cooling_rate}')

    plt.xlabel('Iteration')
    plt.ylabel('Fitness (Total Distance)')
    plt.title('Fitness vs. Iteration for Different Cooling Rates')
    plt.legend()
    plt.grid(True)
    plt.show()

# Parameters
num_cities = 100  # Number of cities
max_iterations = 1000  # Maximum number of iterations
num_runs = 10  # Number of runs
seeds = [i for i in range(num_runs)]  # Generate N seeds

# Different initial temperatures to test
initial_temps = [500, 1000, 1500, 2000]

# Plot fitness vs. iteration for different initial temperatures
cooling_rate = 0.995  # Use a fixed cooling rate for this plot
plot_fitness_vs_iteration_initial_temp(initial_temps, num_cities, max_iterations, num_runs, seeds, cooling_rate)

# Different cooling rates to test
cooling_rates = [0.99, 0.995, 0.998, 0.999]

# Use the best initial temperature (you can choose based on the previous plot)
best_initial_temp = 1000

# Plot fitness vs. iteration for different cooling rates
plot_fitness_vs_iteration_cooling_rate(cooling_rates, num_cities, max_iterations, num_runs, seeds, best_initial_temp)

import mlrose_hiive as mlrose
import numpy as np
import random
import matplotlib.pyplot as plt

# Define the distance matrix
def create_distance_matrix(num_cities):
    np.random.seed(42)
    coords = np.random.rand(num_cities, 2)
    dist_matrix = np.linalg.norm(coords[:, np.newaxis] - coords, axis=2)
    return dist_matrix

# Define the fitness function
def tsp_fitness(route, dist_matrix):
    total_distance = sum(dist_matrix[route[i], route[i + 1]] for i in range(len(route) - 1))
    total_distance += dist_matrix[route[-1], route[0]]  # return to start
    return total_distance

# Create an initial population
def create_population(pop_size, num_cities):
    population = []
    for _ in range(pop_size):
        route = list(range(num_cities))
        random.shuffle(route)
        population.append(route)
    return population

# Select parents based on fitness
def select_parents(population, dist_matrix):
    fitness_scores = [1 / tsp_fitness(route, dist_matrix) for route in population]
    total_fitness = sum(fitness_scores)
    selection_probs = [score / total_fitness for score in fitness_scores]
    parents = random.choices(population, weights=selection_probs, k=len(population))
    return parents

# Perform crossover between two parents to produce offspring
def crossover(parent1, parent2):
    size = len(parent1)
    start, end = sorted(random.sample(range(size), 2))
    child = [-1] * size
    child[start:end] = parent1[start:end]
    fill_idx = end
    for gene in parent2:
        if gene not in child:
            while child[fill_idx] != -1:
                fill_idx = (fill_idx + 1) % size
            child[fill_idx] = gene
    return child

# Perform mutation on a route
def mutate(route, mutation_rate):
    for i in range(len(route)):
        if random.random() < mutation_rate:
            j = random.randint(0, len(route) - 1)
            route[i], route[j] = route[j], route[i]
    return route

# Genetic Algorithm for TSP
def genetic_algorithm_tsp(dist_matrix, pop_size, num_generations, mutation_rate, seed):
    np.random.seed(seed)
    random.seed(seed)

    num_cities = len(dist_matrix)
    population = create_population(pop_size, num_cities)
    best_route = min(population, key=lambda route: tsp_fitness(route, dist_matrix))
    best_fitness = tsp_fitness(best_route, dist_matrix)

    fitness_history = [best_fitness]

    for _ in range(num_generations):
        parents = select_parents(population, dist_matrix)
        population = [mutate(crossover(parents[i], parents[len(parents) - i - 1]), mutation_rate) for i in range(len(parents))]
        current_best_route = min(population, key=lambda route: tsp_fitness(route, dist_matrix))
        current_best_fitness = tsp_fitness(current_best_route, dist_matrix)
        if current_best_fitness < best_fitness:
            best_route = current_best_route
            best_fitness = current_best_fitness
        fitness_history.append(best_fitness)

    return best_route, best_fitness, fitness_history

# Run experiments with multiple seeds
def run_experiments(num_cities, pop_size, num_generations, mutation_rate, num_runs, seeds):
    all_fitness_histories = []
    dist_matrix = create_distance_matrix(num_cities)

    for seed in seeds:
        _, _, fitness_history = genetic_algorithm_tsp(dist_matrix, pop_size, num_generations, mutation_rate, seed)
        all_fitness_histories.append(fitness_history)

    return np.array(all_fitness_histories)

# Plot the best fitness with variance
def plot_best_fitness(fitness_histories, title):
    best_fitness = np.max(fitness_histories, axis=0)
    avg_fitness = np.mean(fitness_histories, axis=0)
    std_fitness = np.std(fitness_histories, axis=0)

    plt.figure(figsize=(10, 6))
    plt.step(range(len(best_fitness)), best_fitness, label='Best Fitness', where='post')
    plt.fill_between(range(len(avg_fitness)), avg_fitness - std_fitness, avg_fitness + std_fitness, alpha=0.2, label='Variance', step='post')
    plt.xlabel('Iteration')
    plt.ylabel('Fitness (Total Distance)')
    plt.title(title)
    plt.legend()
    plt.grid(True)
    plt.show()

# Parameters for Genetic Algorithm
num_cities = 100  # Number of cities
pop_size = 100  # Population size
num_generations = 5000  # Number of generations
mutation_rate = 10  # Mutation rate
num_runs = 50  # Number of runs
seeds = [i for i in range(num_runs)]  # Generate N seeds

# Run experiments
all_fitness_histories = run_experiments(num_cities, pop_size, num_generations, mutation_rate, num_runs, seeds)

# Plot best fitness
plot_best_fitness(all_fitness_histories, 'Best Fitness (Genetic Algorithm)')

# import mlrose_hiive as mlrose
import numpy as np
import random
import matplotlib.pyplot as plt

# Define the distance matrix
def create_distance_matrix(num_cities):
    np.random.seed(42)
    coords = np.random.rand(num_cities, 2)
    dist_matrix = np.linalg.norm(coords[:, np.newaxis] - coords, axis=2)
    return dist_matrix

# Define the fitness function
def lpp_fitness(route, dist_matrix):
    total_distance = sum(dist_matrix[route[i], route[i + 1]] for i in range(len(route) - 1))
    total_distance += dist_matrix[route[-1], route[0]]  # return to start
    return -total_distance  # Negate the total distance to maximize it

# Create an initial population
def create_population(pop_size, num_cities):
    population = []
    for _ in range(pop_size):
        route = list(range(num_cities))
        random.shuffle(route)
        population.append(route)
    return population

# Select parents based on fitness
def select_parents(population, dist_matrix):
    fitness_scores = [1 / lpp_fitness(route, dist_matrix) for route in population]
    total_fitness = sum(fitness_scores)
    selection_probs = [score / total_fitness for score in fitness_scores]
    parents = random.choices(population, weights=selection_probs, k=len(population))
    return parents

# Perform crossover between two parents to produce offspring
def crossover(parent1, parent2):
    size = len(parent1)
    start, end = sorted(random.sample(range(size), 2))
    child = [-1] * size
    child[start:end] = parent1[start:end]
    fill_idx = end
    for gene in parent2:
        if gene not in child:
            while child[fill_idx] != -1:
                fill_idx = (fill_idx + 1) % size
            child[fill_idx] = gene
    return child

# Perform mutation on a route
def mutate(route, mutation_rate):
    for i in range(len(route)):
        if random.random() < mutation_rate:
            j = random.randint(0, len(route) - 1)
            route[i], route[j] = route[j], route[i]
    return route

# Genetic Algorithm for LPP
def genetic_algorithm_lpp(dist_matrix, pop_size, num_generations, mutation_rate, seed):
    np.random.seed(seed)
    random.seed(seed)

    num_cities = len(dist_matrix)
    population = create_population(pop_size, num_cities)
    best_route = max(population, key=lambda route: lpp_fitness(route, dist_matrix))
    best_fitness = lpp_fitness(best_route, dist_matrix)

    fitness_history = [best_fitness]

    for _ in range(num_generations):
        parents = select_parents(population, dist_matrix)
        population = [mutate(crossover(parents[i], parents[len(parents) - i - 1]), mutation_rate) for i in range(len(parents))]
        current_best_route = max(population, key=lambda route: lpp_fitness(route, dist_matrix))
        current_best_fitness = lpp_fitness(current_best_route, dist_matrix)
        if current_best_fitness > best_fitness:
            best_route = current_best_route
            best_fitness = current_best_fitness
        fitness_history.append(best_fitness)

    return best_route, best_fitness, fitness_history

# Run experiments with multiple seeds
def run_experiments(num_cities, pop_size, num_generations, mutation_rate, num_runs, seeds):
    all_fitness_histories = []
    dist_matrix = create_distance_matrix(num_cities)

    for seed in seeds:
        _, _, fitness_history = genetic_algorithm_lpp(dist_matrix, pop_size, num_generations, mutation_rate, seed)
        all_fitness_histories.append(fitness_history)

    return np.array(all_fitness_histories)

# Plot the best fitness with variance
def plot_best_fitness(fitness_histories, title):
    best_fitness = np.max(fitness_histories, axis=0)
    avg_fitness = np.mean(fitness_histories, axis=0)
    std_fitness = np.std(fitness_histories, axis=0)

    plt.figure(figsize=(10, 6))
    plt.step(range(len(best_fitness)), best_fitness, label='Best Fitness', where='post')
    plt.fill_between(range(len(avg_fitness)), avg_fitness - std_fitness, avg_fitness + std_fitness, alpha=0.2, label='Variance', step='post')
    plt.xlabel('Iteration')
    plt.ylabel('Fitness (Total Distance)')
    plt.title(title)
    plt.legend()
    plt.grid(True)
    plt.show()

# Parameters for Genetic Algorithm
num_cities = 100  # Number of cities
pop_size = 100  # Population size
num_generations = 5000  # Number of generations
mutation_rate = 10  # Mutation rate
num_runs = 50  # Number of runs
seeds = [i for i in range(num_runs)]  # Generate N seeds

# Run experiments
all_fitness_histories = run_experiments(num_cities, pop_size, num_generations, mutation_rate, num_runs, seeds)

# Plot best fitness
plot_best_fitness(all_fitness_histories, 'Best Fitness (Genetic Algorithm)')

import mlrose_hiive as mlrose
import numpy as np
import random
import matplotlib.pyplot as plt

# Define the distance matrix
def create_distance_matrix(num_cities):
    np.random.seed(42)
    coords = np.random.rand(num_cities, 2)
    dist_matrix = np.linalg.norm(coords[:, np.newaxis] - coords, axis=2)
    return dist_matrix

# Define the fitness function
def tsp_fitness(route, dist_matrix):
    total_distance = sum(dist_matrix[route[i], route[i + 1]] for i in range(len(route) - 1))
    total_distance += dist_matrix[route[-1], route[0]]  # return to start
    return total_distance

# Create an initial population
def create_population(pop_size, num_cities):
    population = []
    for _ in range(pop_size):
        route = list(range(num_cities))
        random.shuffle(route)
        population.append(route)
    return population

# Select parents based on fitness
def select_parents(population, dist_matrix):
    fitness_scores = [1 / tsp_fitness(route, dist_matrix) for route in population]
    total_fitness = sum(fitness_scores)
    selection_probs = [score / total_fitness for score in fitness_scores]
    parents = random.choices(population, weights=selection_probs, k=len(population))
    return parents

# Perform crossover between two parents to produce offspring
def crossover(parent1, parent2):
    size = len(parent1)
    start, end = sorted(random.sample(range(size), 2))
    child = [-1] * size
    child[start:end] = parent1[start:end]
    fill_idx = end
    for gene in parent2:
        if gene not in child:
            while child[fill_idx] != -1:
                fill_idx = (fill_idx + 1) % size
            child[fill_idx] = gene
    return child

# Perform mutation on a route
def mutate(route, mutation_rate):
    for i in range(len(route)):
        if random.random() < mutation_rate:
            j = random.randint(0, len(route) - 1)
            route[i], route[j] = route[j], route[i]
    return route

# Genetic Algorithm for TSP
def genetic_algorithm_tsp(dist_matrix, pop_size, num_generations, mutation_rate, seed):
    np.random.seed(seed)
    random.seed(seed)

    num_cities = len(dist_matrix)
    population = create_population(pop_size, num_cities)
    best_route = min(population, key=lambda route: tsp_fitness(route, dist_matrix))
    best_fitness = tsp_fitness(best_route, dist_matrix)

    fitness_history = [best_fitness]

    for _ in range(num_generations):
        parents = select_parents(population, dist_matrix)
        population = [mutate(crossover(parents[i], parents[len(parents) - i - 1]), mutation_rate) for i in range(len(parents))]
        current_best_route = min(population, key=lambda route: tsp_fitness(route, dist_matrix))
        current_best_fitness = tsp_fitness(current_best_route, dist_matrix)
        if current_best_fitness < best_fitness:
            best_route = current_best_route
            best_fitness = current_best_fitness
        fitness_history.append(best_fitness)

    return best_route, best_fitness, fitness_history

# Run experiments with multiple seeds
def run_experiments(num_cities, pop_size, num_generations, mutation_rate, num_runs, seeds):
    all_fitness_histories = []
    dist_matrix = create_distance_matrix(num_cities)

    for seed in seeds:
        _, _, fitness_history = genetic_algorithm_tsp(dist_matrix, pop_size, num_generations, mutation_rate, seed)
        all_fitness_histories.append(fitness_history)

    return np.array(all_fitness_histories)

# Plot fitness vs. iteration for different mutation rates
def plot_fitness_vs_iteration_mutation_rate(mutation_rates, num_cities, pop_size, num_generations, num_runs, seeds):
    plt.figure(figsize=(10, 6))
    for mutation_rate in mutation_rates:
        fitness_histories = run_experiments(num_cities, pop_size, num_generations, mutation_rate, num_runs, seeds)
        avg_fitness = np.mean(fitness_histories, axis=0)
        plt.plot(avg_fitness, label=f'Mutation Rate: {mutation_rate}')

    plt.xlabel('Iteration')
    plt.ylabel('Fitness (Total Distance)')
    plt.title('Fitness vs. Iteration for Different Mutation Rates')
    plt.legend()
    plt.grid(True)
    plt.show()

# Parameters for Genetic Algorithm
num_cities = 100  # Number of cities
pop_size = 100  # Population size
num_generations = 100  # Number of generations (reduced for faster computation)
num_runs = 10  # Number of runs (reduced for faster computation)
seeds = [i for i in range(num_runs)]  # Generate N seeds

# Different mutation rates to test
mutation_rates = [0.001, .01, .1, 1,10,100]

# Plot fitness vs. iteration for different mutation rates
plot_fitness_vs_iteration_mutation_rate(mutation_rates, num_cities, pop_size, num_generations, num_runs, seeds)

import numpy as np
import random
import matplotlib.pyplot as plt

# Define the distance matrix
def create_distance_matrix(num_cities):
    np.random.seed(42)
    coords = np.random.rand(num_cities, 2)
    dist_matrix = np.linalg.norm(coords[:, np.newaxis] - coords, axis=2)
    return dist_matrix

# Define the fitness function for Longest Path Problem
def lpp_fitness(route, dist_matrix):
    total_distance = sum(dist_matrix[route[i], route[i + 1]] for i in range(len(route) - 1))
    total_distance += dist_matrix[route[-1], route[0]]  # return to start
    return total_distance

# Create an initial population
def create_population(pop_size, num_cities):
    population = []
    for _ in range(pop_size):
        route = list(range(num_cities))
        random.shuffle(route)
        population.append(route)
    return population

# Select parents based on fitness
def select_parents(population, dist_matrix):
    fitness_scores = [lpp_fitness(route, dist_matrix) for route in population]
    total_fitness = sum(fitness_scores)
    selection_probs = [score / total_fitness for score in fitness_scores]
    parents = random.choices(population, weights=selection_probs, k=len(population))
    return parents

# Perform crossover between two parents to produce offspring
def crossover(parent1, parent2):
    size = len(parent1)
    start, end = sorted(random.sample(range(size), 2))
    child = [-1] * size
    child[start:end] = parent1[start:end]
    fill_idx = end
    for gene in parent2:
        if gene not in child:
            while child[fill_idx] != -1:
                fill_idx = (fill_idx + 1) % size
            child[fill_idx] = gene
    return child

# Perform mutation on a route
def mutate(route, mutation_rate):
    for i in range(len(route)):
        if random.random() < mutation_rate:
            j = random.randint(0, len(route) - 1)
            route[i], route[j] = route[j], route[i]
    return route

# Genetic Algorithm for Longest Path Problem
def genetic_algorithm_lpp(dist_matrix, pop_size, num_generations, mutation_rate, seed):
    np.random.seed(seed)
    random.seed(seed)

    num_cities = len(dist_matrix)
    population = create_population(pop_size, num_cities)
    best_route = max(population, key=lambda route: lpp_fitness(route, dist_matrix))
    best_fitness = lpp_fitness(best_route, dist_matrix)

    fitness_history = [best_fitness]

    for _ in range(num_generations):
        parents = select_parents(population, dist_matrix)
        population = [mutate(crossover(parents[i], parents[len(parents) - i - 1]), mutation_rate) for i in range(len(parents))]
        current_best_route = max(population, key=lambda route: lpp_fitness(route, dist_matrix))
        current_best_fitness = lpp_fitness(current_best_route, dist_matrix)
        if current_best_fitness > best_fitness:
            best_route = current_best_route
            best_fitness = current_best_fitness
        fitness_history.append(best_fitness)

    return best_route, best_fitness, fitness_history

# Run experiments with multiple seeds
def run_experiments(num_cities, pop_size, num_generations, mutation_rate, num_runs, seeds):
    all_fitness_histories = []
    dist_matrix = create_distance_matrix(num_cities)

    for seed in seeds:
        _, _, fitness_history = genetic_algorithm_lpp(dist_matrix, pop_size, num_generations, mutation_rate, seed)
        all_fitness_histories.append(fitness_history)

    return np.array(all_fitness_histories)

# Plot fitness vs. iteration for different mutation rates
def plot_fitness_vs_iteration_mutation_rate(mutation_rates, num_cities, pop_size, num_generations, num_runs, seeds):
    plt.figure(figsize=(10, 6))
    for mutation_rate in mutation_rates:
        fitness_histories = run_experiments(num_cities, pop_size, num_generations, mutation_rate, num_runs, seeds)
        avg_fitness = np.mean(fitness_histories, axis=0)
        plt.plot(avg_fitness, label=f'Mutation Rate: {mutation_rate}')

    plt.xlabel('Iteration')
    plt.ylabel('Fitness (Total Distance)')
    plt.title('Fitness vs. Iteration for Different Mutation Rates')
    plt.legend()
    plt.grid(True)
    plt.show()

# Parameters for Genetic Algorithm
num_cities = 100  # Number of cities
pop_size = 100  # Population size
num_generations = 100  # Number of generations (reduced for faster computation)
num_runs = 10  # Number of runs (reduced for faster computation)
seeds = [i for i in range(num_runs)]  # Generate N seeds

# Different mutation rates to test
mutation_rates = [0.001, .01, .1, 1,10,100]

# Plot fitness vs. iteration for different mutation rates
plot_fitness_vs_iteration_mutation_rate(mutation_rates, num_cities, pop_size, num_generations, num_runs, seeds)

import mlrose_hiive as mlrose
import numpy as np
import random
import matplotlib.pyplot as plt

# Define the distance matrix
def create_distance_matrix(num_cities):
    np.random.seed(42)
    coords = np.random.rand(num_cities, 2)
    dist_matrix = np.linalg.norm(coords[:, np.newaxis] - coords, axis=2)
    return dist_matrix

# Define the fitness function for the Longest Path Problem
def lpp_fitness(route, dist_matrix):
    total_distance = sum(dist_matrix[route[i], route[i + 1]] for i in range(len(route) - 1))
    total_distance += dist_matrix[route[-1], route[0]]  # return to start
    return total_distance  # Maximize the total distance

# Create an initial population
def create_population(pop_size, num_cities):
    population = []
    for _ in range(pop_size):
        route = list(range(num_cities))
        random.shuffle(route)
        population.append(route)
    return population

# Select parents based on fitness
def select_parents(population, dist_matrix):
    fitness_scores = [lpp_fitness(route, dist_matrix) for route in population]
    total_fitness = sum(fitness_scores)
    selection_probs = [score / total_fitness for score in fitness_scores]
    parents = random.choices(population, weights=selection_probs, k=len(population))
    return parents

# Perform crossover between two parents to produce offspring
def crossover(parent1, parent2):
    size = len(parent1)
    start, end = sorted(random.sample(range(size), 2))
    child = [-1] * size
    child[start:end] = parent1[start:end]
    fill_idx = end
    for gene in parent2:
        if gene not in child:
            while child[fill_idx] != -1:
                fill_idx = (fill_idx + 1) % size
            child[fill_idx] = gene
    return child

# Perform mutation on a route
def mutate(route, mutation_rate):
    for i in range(len(route)):
        if random.random() < mutation_rate:
            j = random.randint(0, len(route) - 1)
            route[i], route[j] = route[j], route[i]
    return route

# Genetic Algorithm for LPP
def genetic_algorithm_lpp(dist_matrix, pop_size, num_generations, mutation_rate, seed):
    np.random.seed(seed)
    random.seed(seed)

    num_cities = len(dist_matrix)
    population = create_population(pop_size, num_cities)
    best_route = max(population, key=lambda route: lpp_fitness(route, dist_matrix))
    best_fitness = lpp_fitness(best_route, dist_matrix)

    fitness_history = [best_fitness]

    for _ in range(num_generations):
        parents = select_parents(population, dist_matrix)
        population = [mutate(crossover(parents[i], parents[len(parents) - i - 1]), mutation_rate) for i in range(len(parents))]
        current_best_route = max(population, key=lambda route: lpp_fitness(route, dist_matrix))
        current_best_fitness = lpp_fitness(current_best_route, dist_matrix)
        if current_best_fitness > best_fitness:
            best_route = current_best_route
            best_fitness = current_best_fitness
        fitness_history.append(best_fitness)

    return best_route, best_fitness, fitness_history

# Run experiments with multiple seeds
def run_experiments(num_cities, pop_size, num_generations, mutation_rate, num_runs, seeds):
    all_fitness_histories = []
    dist_matrix = create_distance_matrix(num_cities)

    for seed in seeds:
        _, _, fitness_history = genetic_algorithm_lpp(dist_matrix, pop_size, num_generations, mutation_rate, seed)
        all_fitness_histories.append(fitness_history)

    return np.array(all_fitness_histories)

# Plot the best fitness with variance
def plot_best_fitness(fitness_histories, title):
    best_fitness = np.max(fitness_histories, axis=0)
    avg_fitness = np.mean(fitness_histories, axis=0)
    std_fitness = np.std(fitness_histories, axis=0)

    plt.figure(figsize=(10, 6))
    plt.step(range(len(best_fitness)), best_fitness, label='Best Fitness', where='post')
    plt.fill_between(range(len(avg_fitness)), avg_fitness - std_fitness, avg_fitness + std_fitness, alpha=0.2, label='Variance', step='post')
    plt.xlabel('Iteration')
    plt.ylabel('Fitness (Total Distance)')
    plt.title(title)
    plt.legend()
    plt.grid(True)
    plt.show()

# Parameters for Genetic Algorithm
num_cities = 100  # Number of cities
pop_size = 100  # Population size
num_generations = 5000  # Number of generations
mutation_rate = 0.01  # Mutation rate
num_runs = 50  # Number of runs
seeds = [i for i in range(num_runs)]  # Generate N seeds

# Run experiments
all_fitness_histories = run_experiments(num_cities, pop_size, num_generations, mutation_rate, num_runs, seeds)

# Plot best fitness
plot_best_fitness(all_fitness_histories, 'Best Fitness (Genetic Algorithm)')

import mlrose_hiive as mlrose
import numpy as np
import random
import matplotlib.pyplot as plt
import pandas as pd

# Define the Longest Path problem
def create_longest_path_problem(num_nodes):
    np.random.seed(42)
    adj_matrix = np.random.randint(1, 10, size=(num_nodes, num_nodes))
    np.fill_diagonal(adj_matrix, 0)
    return adj_matrix

# Define the fitness function for the Longest Path problem
def longest_path_fitness(path, adj_matrix):
    total_length = sum(adj_matrix[path[i], path[i + 1]] for i in range(len(path) - 1))
    return total_length

# Swap two nodes in the path
def swap_two_nodes(path):
    new_path = path.copy()
    i, j = random.sample(range(len(path)), 2)
    new_path[i], new_path[j] = new_path[j], new_path[i]
    return new_path

# Randomized Hill Climbing algorithm for Longest Path problem
def randomized_hill_climbing_longest_path(adj_matrix, max_iterations, seed):
    np.random.seed(seed)
    random.seed(seed)

    num_nodes = len(adj_matrix)
    current_path = list(range(num_nodes))
    random.shuffle(current_path)
    current_fitness = longest_path_fitness(current_path, adj_matrix)

    fitness_history = [current_fitness]

    for _ in range(max_iterations):
        new_path = swap_two_nodes(current_path)
        new_fitness = longest_path_fitness(new_path, adj_matrix)

        if new_fitness > current_fitness:
            current_path = new_path
            current_fitness = new_fitness

        fitness_history.append(current_fitness)

    return current_path, current_fitness, fitness_history

# Run experiments with different problem sizes
def run_experiments_with_problem_sizes(problem_sizes, max_iterations, num_runs, seeds):
    avg_fitness_per_size = []
    fitness_results_per_size = []

    for size in problem_sizes:
        fitness_results = []
        for seed in seeds:
            adj_matrix = create_longest_path_problem(size)
            _, best_fitness, _ = randomized_hill_climbing_longest_path(adj_matrix, max_iterations, seed)
            fitness_results.append(best_fitness)
        avg_fitness_per_size.append(np.mean(fitness_results))
        fitness_results_per_size.append(fitness_results)

    return avg_fitness_per_size, fitness_results_per_size

# Plot fitness vs. problem size
def plot_fitness_vs_problem_size(problem_sizes, avg_fitness_per_size):
    plt.figure(figsize=(10, 6))
    plt.plot(problem_sizes, avg_fitness_per_size, marker='o')
    plt.xlabel('Problem Size (Number of Nodes)')
    plt.ylabel('Fitness (Longest Path Length)')
    plt.title('Fitness vs. Problem Size for Randomized Hill Climbing (Longest Path Problem)')
    plt.grid(True)
    plt.show()

# Parameters for Randomized Hill Climbing
problem_sizes = [10, 100, 1000, 5000]  # Different problem sizes
max_iterations = 1000  # Maximum number of iterations
num_runs = 10  # Number of runs
seeds = [i for i in range(num_runs)]  # Generate N seeds

# Run experiments
avg_fitness_per_size, fitness_results_per_size = run_experiments_with_problem_sizes(problem_sizes, max_iterations, num_runs, seeds)

# Plot fitness vs. problem size
plot_fitness_vs_problem_size(problem_sizes, avg_fitness_per_size)

# Display fitness results in a table
fitness_results_df = pd.DataFrame(fitness_results_per_size, index=problem_sizes).T
fitness_results_df.columns = [f'Problem Size {size}' for size in problem_sizes]
fitness_results_df.index.name = 'Run'
print(fitness_results_df)

import mlrose_hiive as mlrose
import numpy as np
import random
import matplotlib.pyplot as plt
import pandas as pd

# Define the Longest Path problem
def create_longest_path_problem(num_nodes):
    np.random.seed(42)
    adj_matrix = np.random.randint(1, 10, size=(num_nodes, num_nodes))
    np.fill_diagonal(adj_matrix, 0)
    return adj_matrix

# Define the fitness function for the Longest Path problem
def longest_path_fitness(path, adj_matrix):
    total_length = sum(adj_matrix[path[i], path[i + 1]] for i in range(len(path) - 1))
    return total_length

# Swap two nodes in the path
def swap_two_nodes(path):
    new_path = path.copy()
    i, j = random.sample(range(len(path)), 2)
    new_path[i], new_path[j] = new_path[j], new_path[i]
    return new_path

# Simulated Annealing algorithm for Longest Path problem
def simulated_annealing_longest_path(adj_matrix, max_iterations, seed, initial_temp, cooling_rate):
    np.random.seed(seed)
    random.seed(seed)

    num_nodes = len(adj_matrix)
    current_path = list(range(num_nodes))
    random.shuffle(current_path)
    current_fitness = longest_path_fitness(current_path, adj_matrix)
    best_path = current_path
    best_fitness = current_fitness

    fitness_history = [current_fitness]
    temperature = initial_temp

    for _ in range(max_iterations):
        new_path = swap_two_nodes(current_path)
        new_fitness = longest_path_fitness(new_path, adj_matrix)
        delta_fitness = new_fitness - current_fitness

        if delta_fitness > 0 or random.random() < np.exp(delta_fitness / temperature):
            current_path = new_path
            current_fitness = new_fitness

            if new_fitness > best_fitness:
                best_path = new_path
                best_fitness = new_fitness

        fitness_history.append(current_fitness)
        temperature *= cooling_rate

    return best_path, best_fitness, fitness_history

# Run experiments with different problem sizes
def run_experiments_with_problem_sizes(problem_sizes, max_iterations, num_runs, seeds, initial_temp, cooling_rate):
    avg_fitness_per_size = []
    fitness_results_per_size = []

    for size in problem_sizes:
        fitness_results = []
        for seed in seeds:
            adj_matrix = create_longest_path_problem(size)
            _, best_fitness, _ = simulated_annealing_longest_path(adj_matrix, max_iterations, seed, initial_temp, cooling_rate)
            fitness_results.append(best_fitness)
        avg_fitness_per_size.append(np.mean(fitness_results))
        fitness_results_per_size.append(fitness_results)

    return avg_fitness_per_size, fitness_results_per_size

# Plot fitness vs. problem size
def plot_fitness_vs_problem_size(problem_sizes, avg_fitness_per_size):
    plt.figure(figsize=(10, 6))
    plt.plot(problem_sizes, avg_fitness_per_size, marker='o')
    plt.xlabel('Problem Size (Number of Nodes)')
    plt.ylabel('Fitness (Longest Path Length)')
    plt.title('Fitness vs. Problem Size for Simulated Annealing (Longest Path Problem)')
    plt.grid(True)
    plt.show()

# Parameters for Simulated Annealing
problem_sizes = [10, 100, 1000, 5000]  # Different problem sizes
max_iterations = 1000  # Maximum number of iterations
num_runs = 10  # Number of runs
seeds = [i for i in range(num_runs)]  # Generate N seeds
initial_temp = 1000  # Initial temperature
cooling_rate = 0.995  # Cooling rate

# Run experiments
avg_fitness_per_size, fitness_results_per_size = run_experiments_with_problem_sizes(problem_sizes, max_iterations, num_runs, seeds, initial_temp, cooling_rate)

# Plot fitness vs. problem size
plot_fitness_vs_problem_size(problem_sizes, avg_fitness_per_size)

# Display fitness results in a table
fitness_results_df = pd.DataFrame(fitness_results_per_size, index=problem_sizes).T
fitness_results_df.columns = [f'Problem Size {size}' for size in problem_sizes]
fitness_results_df.index.name = 'Run'
print(fitness_results_df)

# import numpy as np
# import random
# import matplotlib.pyplot as plt

# # Define the Longest Path problem
# def create_longest_path_problem(num_nodes):
#     np.random.seed(42)
#     adj_matrix = np.random.randint(1, 10, size=(num_nodes, num_nodes))
#     np.fill_diagonal(adj_matrix, 0)
#     return adj_matrix

# # Define the fitness function for the Longest Path problem
# def longest_path_fitness(path, adj_matrix):
#     total_length = sum(adj_matrix[path[i], path[i + 1]] for i in range(len(path) - 1))
#     return total_length

# # Create an initial population
# def create_population(pop_size, num_nodes):
#     population = []
#     for _ in range(pop_size):
#         path = list(range(num_nodes))
#         random.shuffle(path)
#         population.append(path)
#     return population

# # Select parents based on fitness
# def select_parents(population, adj_matrix):
#     fitness_scores = [longest_path_fitness(path, adj_matrix) for path in population]
#     total_fitness = sum(fitness_scores)
#     if total_fitness == 0:
#         selection_probs = [1 / len(fitness_scores)] * len(fitness_scores)
#     else:
#         selection_probs = [score / total_fitness for score in fitness_scores]
#     parents = random.choices(population, weights=selection_probs, k=len(population))
#     return parents

# # Perform crossover between two parents to produce offspring
# def crossover(parent1, parent2):
#     size = len(parent1)
#     start, end = sorted(random.sample(range(size), 2))
#     child = [-1] * size
#     child[start:end] = parent1[start:end]
#     fill_idx = end
#     for gene in parent2:
#         if gene not in child[start:end]:
#             while child[fill_idx] != -1:
#                 fill_idx = (fill_idx + 1) % size
#             child[fill_idx] = gene
#     return child

# # Perform mutation on a path
# def mutate(path, mutation_rate):
#     for i in range(len(path)):
#         if random.random() < mutation_rate:
#             j = random.randint(0, len(path) - 1)
#             path[i], path[j] = path[j], path[i]
#     return path

# # Genetic Algorithm for Longest Path problem
# def genetic_algorithm_longest_path(adj_matrix, pop_size, num_generations, mutation_rate, seed):
#     np.random.seed(seed)
#     random.seed(seed)

#     num_nodes = len(adj_matrix)
#     population = create_population(pop_size, num_nodes)
#     best_path = max(population, key=lambda path: longest_path_fitness(path, adj_matrix))
#     best_fitness = longest_path_fitness(best_path, adj_matrix)

#     fitness_history = [best_fitness]

#     for _ in range(num_generations):
#         parents = select_parents(population, adj_matrix)
#         population = [mutate(crossover(parents[i], parents[len(parents) - i - 1]), mutation_rate) for i in range(len(parents))]
#         current_best_path = max(population, key=lambda path: longest_path_fitness(path, adj_matrix))
#         current_best_fitness = longest_path_fitness(current_best_path, adj_matrix)
#         if current_best_fitness > best_fitness:
#             best_path = current_best_path
#             best_fitness = current_best_fitness
#         fitness_history.append(best_fitness)

#     return best_path, best_fitness, fitness_history

# # Run experiments with different problem sizes
# def run_experiments_with_problem_sizes(problem_sizes, pop_size, num_generations, mutation_rate, num_runs, seeds):
#     avg_fitness_per_size = []

#     for size in problem_sizes:
#         fitness_results = []
#         for seed in seeds:
#             adj_matrix = create_longest_path_problem(size)
#             _, best_fitness, _ = genetic_algorithm_longest_path(adj_matrix, pop_size, num_generations, mutation_rate, seed)
#             fitness_results.append(best_fitness)
#         avg_fitness_per_size.append(np.mean(fitness_results))

#     return avg_fitness_per_size

# # Plot fitness vs. problem size
# def plot_fitness_vs_problem_size(problem_sizes, avg_fitness_per_size):
#     plt.figure(figsize=(10, 6))
#     plt.plot(problem_sizes, avg_fitness_per_size, marker='o')
#     plt.xlabel('Problem Size (Number of Nodes)')
#     plt.ylabel('Fitness (Longest Path Length)')
#     plt.title('Fitness vs. Problem Size for Genetic Algorithm (Longest Path Problem)')
#     plt.grid(True)
#     plt.show()

# # Parameters for Genetic Algorithm
# problem_sizes = [10, 100, 1000, 5000]  # Different problem sizes
# pop_size = 100  # Population size
# num_generations = 100  # Number of generations
# mutation_rate = 0.01  # Mutation rate
# num_runs = 10  # Number of runs
# seeds = [i for i in range(num_runs)]  # Generate N seeds

# # Run experiments
# avg_fitness_per_size = run_experiments_with_problem_sizes(problem_sizes, pop_size, num_generations, mutation_rate, num_runs, seeds)

# # Plot fitness vs. problem size
# plot_fitness_vs_problem_size(problem_sizes, avg_fitness_per_size)

import mlrose_hiive as mlrose
import numpy as np
import random
import matplotlib.pyplot as plt
import pandas as pd

# Define the Longest Path problem
def create_longest_path_problem(num_nodes):
    np.random.seed(42)
    adj_matrix = np.random.randint(1, 10, size=(num_nodes, num_nodes))
    np.fill_diagonal(adj_matrix, 0)
    return adj_matrix

# Define the fitness function for the Longest Path problem
def longest_path_fitness(path, adj_matrix):
    total_length = sum(adj_matrix[path[i], path[i + 1]] for i in range(len(path) - 1))
    return total_length

# Create an initial population
def create_population(pop_size, num_nodes):
    population = []
    for _ in range(pop_size):
        path = list(range(num_nodes))
        random.shuffle(path)
        population.append(path)
    return population

# Select parents based on fitness
def select_parents(population, adj_matrix):
    fitness_scores = [longest_path_fitness(path, adj_matrix) for path in population]
    total_fitness = sum(fitness_scores)
    if total_fitness == 0:
        selection_probs = [1 / len(fitness_scores)] * len(fitness_scores)
    else:
        selection_probs = [score / total_fitness for score in fitness_scores]
    parents = random.choices(population, weights=selection_probs, k=len(population))
    return parents

# Perform crossover between two parents to produce offspring
def crossover(parent1, parent2):
    size = len(parent1)
    start, end = sorted(random.sample(range(size), 2))
    child = [-1] * size
    child[start:end] = parent1[start:end]
    fill_idx = end
    for gene in parent2:
        if gene not in child[start:end]:
            while child[fill_idx] != -1:
                fill_idx = (fill_idx + 1) % size
            child[fill_idx] = gene
    return child

# Perform mutation on a path
def mutate(path, mutation_rate):
    for i in range(len(path)):
        if random.random() < mutation_rate:
            j = random.randint(0, len(path) - 1)
            path[i], path[j] = path[j], path[i]
    return path

# Genetic Algorithm for Longest Path problem
def genetic_algorithm_longest_path(adj_matrix, pop_size, num_generations, mutation_rate, seed):
    np.random.seed(seed)
    random.seed(seed)

    num_nodes = len(adj_matrix)
    population = create_population(pop_size, num_nodes)
    best_path = max(population, key=lambda path: longest_path_fitness(path, adj_matrix))
    best_fitness = longest_path_fitness(best_path, adj_matrix)

    fitness_history = [best_fitness]

    for _ in range(num_generations):
        parents = select_parents(population, adj_matrix)
        population = [mutate(crossover(parents[i], parents[len(parents) - i - 1]), mutation_rate) for i in range(len(parents))]
        current_best_path = max(population, key=lambda path: longest_path_fitness(path, adj_matrix))
        current_best_fitness = longest_path_fitness(current_best_path, adj_matrix)
        if current_best_fitness > best_fitness:
            best_path = current_best_path
            best_fitness = current_best_fitness
        fitness_history.append(best_fitness)

    return best_path, best_fitness, fitness_history

# Run experiments with different problem sizes
def run_experiments_with_problem_sizes(problem_sizes, pop_size, num_generations, mutation_rate, num_runs, seeds):
    avg_fitness_per_size = []
    fitness_results_per_size = []

    for size in problem_sizes:
        fitness_results = []
        for seed in seeds:
            adj_matrix = create_longest_path_problem(size)
            _, best_fitness, _ = genetic_algorithm_longest_path(adj_matrix, pop_size, num_generations, mutation_rate, seed)
            fitness_results.append(best_fitness)
        avg_fitness_per_size.append(np.mean(fitness_results))
        fitness_results_per_size.append(fitness_results)

    return avg_fitness_per_size, fitness_results_per_size

# Plot fitness vs. problem size
def plot_fitness_vs_problem_size(problem_sizes, avg_fitness_per_size):
    plt.figure(figsize=(10, 6))
    plt.plot(problem_sizes, avg_fitness_per_size, marker='o')
    plt.xlabel('Problem Size (Number of Nodes)')
    plt.ylabel('Fitness (Longest Path Length)')
    plt.title('Fitness vs. Problem Size for Genetic Algorithm (Longest Path Problem)')
    plt.grid(True)
    plt.show()

# Parameters for Genetic Algorithm
problem_sizes = [10,100,1000,5000 ]  # Different problem sizes
pop_size = 100  # Population size
num_generations = 100  # Number of generations
mutation_rate = 0.01  # Mutation rate
num_runs = 10  # Number of runs
seeds = [i for i in range(num_runs)]  # Generate N seeds

# Run experiments
avg_fitness_per_size, fitness_results_per_size = run_experiments_with_problem_sizes(problem_sizes, pop_size, num_generations, mutation_rate, num_runs, seeds)

# Plot fitness vs. problem size
plot_fitness_vs_problem_size(problem_sizes, avg_fitness_per_size)

# Display fitness results in a table
fitness_results_df = pd.DataFrame(fitness_results_per_size, index=problem_sizes).T
fitness_results_df.columns = [f'Problem Size {size}' for size in problem_sizes]
fitness_results_df.index.name = 'Run'
print(fitness_results_df)

import mlrose_hiive as mlrose
import numpy as np
import random
import matplotlib.pyplot as plt
import pandas as pd

# Define the Longest Path problem
def create_longest_path_problem(num_nodes):
    np.random.seed(42)
    adj_matrix = np.random.randint(1, 10, size=(num_nodes, num_nodes))
    np.fill_diagonal(adj_matrix, 0)
    return adj_matrix

# Define the fitness function for the Longest Path problem
def longest_path_fitness(path, adj_matrix):
    total_length = sum(adj_matrix[path[i], path[i + 1]] for i in range(len(path) - 1))
    return total_length

# Swap two nodes in the path
def swap_two_nodes(path):
    new_path = path.copy()
    i, j = random.sample(range(len(path)), 2)
    new_path[i], new_path[j] = new_path[j], new_path[i]
    return new_path

# Randomized Hill Climbing algorithm for Longest Path problem
def randomized_hill_climbing_longest_path(adj_matrix, max_iterations, seed):
    np.random.seed(seed)
    random.seed(seed)

    num_nodes = len(adj_matrix)
    current_path = list(range(num_nodes))
    random.shuffle(current_path)
    current_fitness = longest_path_fitness(current_path, adj_matrix)

    fitness_history = [current_fitness]

    for _ in range(max_iterations):
        new_path = swap_two_nodes(current_path)
        new_fitness = longest_path_fitness(new_path, adj_matrix)

        if new_fitness > current_fitness:
            current_path = new_path
            current_fitness = new_fitness

        fitness_history.append(current_fitness)

    return current_path, current_fitness, fitness_history

# Simulated Annealing algorithm for Longest Path problem
def simulated_annealing_longest_path(adj_matrix, max_iterations, seed, initial_temp, cooling_rate):
    np.random.seed(seed)
    random.seed(seed)

    num_nodes = len(adj_matrix)
    current_path = list(range(num_nodes))
    random.shuffle(current_path)
    current_fitness = longest_path_fitness(current_path, adj_matrix)
    best_path = current_path
    best_fitness = current_fitness

    fitness_history = [current_fitness]
    temperature = initial_temp

    for _ in range(max_iterations):
        new_path = swap_two_nodes(current_path)
        new_fitness = longest_path_fitness(new_path, adj_matrix)
        delta_fitness = new_fitness - current_fitness

        if delta_fitness > 0 or random.random() < np.exp(delta_fitness / temperature):
            current_path = new_path
            current_fitness = new_fitness

            if new_fitness > best_fitness:
                best_path = new_path
                best_fitness = new_fitness

        fitness_history.append(current_fitness)
        temperature *= cooling_rate

    return best_path, best_fitness, fitness_history

# Genetic Algorithm for Longest Path problem
def genetic_algorithm_longest_path(adj_matrix, pop_size, num_generations, mutation_rate, seed):
    np.random.seed(seed)
    random.seed(seed)

    num_nodes = len(adj_matrix)
    population = create_population(pop_size, num_nodes)
    best_path = max(population, key=lambda path: longest_path_fitness(path, adj_matrix))
    best_fitness = longest_path_fitness(best_path, adj_matrix)

    fitness_history = [best_fitness]

    for _ in range(num_generations):
        parents = select_parents(population, adj_matrix)
        population = [mutate(crossover(parents[i], parents[len(parents) - i - 1]), mutation_rate) for i in range(len(parents))]
        current_best_path = max(population, key=lambda path: longest_path_fitness(path, adj_matrix))
        current_best_fitness = longest_path_fitness(current_best_path, adj_matrix)
        if current_best_fitness > best_fitness:
            best_path = current_best_path
            best_fitness = current_best_fitness
        fitness_history.append(best_fitness)

    return best_path, best_fitness, fitness_history

# Helper functions for Genetic Algorithm
def create_population(pop_size, num_nodes):
    population = []
    for _ in range(pop_size):
        path = list(range(num_nodes))
        random.shuffle(path)
        population.append(path)
    return population

def select_parents(population, adj_matrix):
    fitness_scores = [longest_path_fitness(path, adj_matrix) for path in population]
    total_fitness = sum(fitness_scores)
    if total_fitness == 0:
        selection_probs = [1 / len(fitness_scores)] * len(fitness_scores)
    else:
        selection_probs = [score / total_fitness for score in fitness_scores]
    parents = random.choices(population, weights=selection_probs, k=len(population))
    return parents

def crossover(parent1, parent2):
    size = len(parent1)
    start, end = sorted(random.sample(range(size), 2))
    child = [-1] * size
    child[start:end] = parent1[start:end]
    fill_idx = end
    for gene in parent2:
        if gene not in child[start:end]:
            while child[fill_idx] != -1:
                fill_idx = (fill_idx + 1) % size
            child[fill_idx] = gene
    return child

def mutate(path, mutation_rate):
    for i in range(len(path)):
        if random.random() < mutation_rate:
            j = random.randint(0, len(path) - 1)
            path[i], path[j] = path[j], path[i]
    return path

# Run experiments with different problem sizes for RHC
def run_experiments_with_problem_sizes_rhc(problem_sizes, max_iterations, num_runs, seeds):
    avg_fitness_per_size = []
    fitness_results_per_size = []

    for size in problem_sizes:
        fitness_results = []
        for seed in seeds:
            adj_matrix = create_longest_path_problem(size)
            _, best_fitness, _ = randomized_hill_climbing_longest_path(adj_matrix, max_iterations, seed)
            fitness_results.append(best_fitness)
        avg_fitness_per_size.append(np.mean(fitness_results))
        fitness_results_per_size.append(fitness_results)

    return avg_fitness_per_size, fitness_results_per_size

# Run experiments with different problem sizes for SA
def run_experiments_with_problem_sizes_sa(problem_sizes, max_iterations, num_runs, seeds, initial_temp, cooling_rate):
    avg_fitness_per_size = []
    fitness_results_per_size = []

    for size in problem_sizes:
        fitness_results = []
        for seed in seeds:
            adj_matrix = create_longest_path_problem(size)
            _, best_fitness, _ = simulated_annealing_longest_path(adj_matrix, max_iterations, seed, initial_temp, cooling_rate)
            fitness_results.append(best_fitness)
        avg_fitness_per_size.append(np.mean(fitness_results))
        fitness_results_per_size.append(fitness_results)

    return avg_fitness_per_size, fitness_results_per_size

# Run experiments with different problem sizes for GA
def run_experiments_with_problem_sizes_ga(problem_sizes, pop_size, num_generations, mutation_rate, num_runs, seeds):
    avg_fitness_per_size = []
    fitness_results_per_size = []

    for size in problem_sizes:
        fitness_results = []
        for seed in seeds:
            adj_matrix = create_longest_path_problem(size)
            _, best_fitness, _ = genetic_algorithm_longest_path(adj_matrix, pop_size, num_generations, mutation_rate, seed)
            fitness_results.append(best_fitness)
        avg_fitness_per_size.append(np.mean(fitness_results))
        fitness_results_per_size.append(fitness_results)

    return avg_fitness_per_size, fitness_results_per_size

# Plot fitness vs. problem size for all algorithms
def plot_fitness_vs_problem_size(problem_sizes, rhc_fitness, sa_fitness, ga_fitness):
    plt.figure(figsize=(10, 6))
    plt.plot(problem_sizes, rhc_fitness, marker='o', label='Randomized Hill Climbing')
    plt.plot(problem_sizes, sa_fitness, marker='o', label='Simulated Annealing')
    plt.plot(problem_sizes, ga_fitness, marker='o', label='Genetic Algorithm')
    plt.xlabel('Problem Size (Number of Nodes)')
    plt.ylabel('Fitness (Longest Path Length)')
    plt.title('Fitness vs. Problem Size for Different Algorithms (Longest Path Problem)')
    plt.legend()
    plt.grid(True)
    plt.show()

# Parameters for the experiments
problem_sizes = [10, 100,1000]  # Different problem sizes
max_iterations = 1000  # Maximum number of iterations for RHC and SA
num_generations = 100  # Number of generations for GA
num_runs = 10  # Number of runs1
seeds = [i for i in range(num_runs)]  # Generate N seeds

# Parameters for Simulated Annealing
initial_temp = 1000  # Initial temperature
cooling_rate = 0.995  # Cooling rate

# Parameters for Genetic Algorithm
pop_size = 100  # Population size
mutation_rate = 0.01  # Mutation rate

# Run experiments for Randomized Hill Climbing
rhc_fitness, rhc_fitness_results = run_experiments_with_problem_sizes_rhc(problem_sizes, max_iterations, num_runs, seeds)

# Run experiments for Simulated Annealing
sa_fitness, sa_fitness_results = run_experiments_with_problem_sizes_sa(problem_sizes, max_iterations, num_runs, seeds, initial_temp, cooling_rate)

# Run experiments for Genetic Algorithm
ga_fitness, ga_fitness_results = run_experiments_with_problem_sizes_ga(problem_sizes, pop_size, num_generations, mutation_rate, num_runs, seeds)

# Plot fitness vs. problem size
plot_fitness_vs_problem_size(problem_sizes, rhc_fitness, sa_fitness, ga_fitness)

# Combine all results into a single DataFrame for display
combined_results = pd.DataFrame({
    'Problem Size': problem_sizes,
    'RHC Average Fitness': rhc_fitness,
    'SA Average Fitness': sa_fitness,
    'GA Average Fitness': ga_fitness
})

print(combined_results)

import matplotlib.pyplot as plt
import mlrose_hiive as mlrose

# Data from the table
problem_sizes = [10, 100, 1000, 5000]
rhc_fitness = [70, 799, 6451, 27201]
sa_fitness = [67, 589, 5268, 25174]
ga_fitness = [72, 594, 5423, 26310]

# Plotting the data
plt.figure(figsize=(10, 6))
plt.plot(problem_sizes, rhc_fitness, marker='o', label='RHC')
plt.plot(problem_sizes, sa_fitness, marker='o', label='SA')
plt.plot(problem_sizes, ga_fitness, marker='o', label='GA')

# Adding labels and title
plt.xlabel('Problem Size (Number of Nodes)')
plt.ylabel('Fitness (Longest Path Length)')
plt.title('Fitness vs. Problem Size for Different Algorithms (Longest Path Problem)')
plt.legend()
plt.grid(True)

# Show the plot
plt.show()

import numpy as np
import random
import matplotlib.pyplot as plt
import time
import mlrose_hiive as mlrose

# Define the Longest Path problem
def create_longest_path_problem(num_nodes):
    np.random.seed(42)
    adj_matrix = np.random.randint(1, 10, size=(num_nodes, num_nodes))
    np.fill_diagonal(adj_matrix, 0)
    return adj_matrix

# Define the fitness function for the Longest Path problem
def longest_path_fitness(path, adj_matrix):
    total_length = sum(adj_matrix[path[i], path[i + 1]] for i in range(len(path) - 1))
    return total_length

# Swap two nodes in the path
def swap_two_nodes(path):
    new_path = path.copy()
    i, j = random.sample(range(len(path)), 2)
    new_path[i], new_path[j] = new_path[j], new_path[i]
    return new_path

# Randomized Hill Climbing algorithm for Longest Path problem
def randomized_hill_climbing_longest_path(adj_matrix, max_iterations, seed):
    np.random.seed(seed)
    random.seed(seed)

    num_nodes = len(adj_matrix)
    current_path = list(range(num_nodes))
    random.shuffle(current_path)
    current_fitness = longest_path_fitness(current_path, adj_matrix)

    fitness_history = [current_fitness]

    for _ in range(max_iterations):
        new_path = swap_two_nodes(current_path)
        new_fitness = longest_path_fitness(new_path, adj_matrix)

        if new_fitness > current_fitness:
            current_path = new_path
            current_fitness = new_fitness

        fitness_history.append(current_fitness)

    return current_path, current_fitness, fitness_history

# Run experiments with different problem sizes
def run_experiments_with_times(problem_sizes, max_iterations, num_runs, seeds):
    avg_times_per_size = []

    for size in problem_sizes:
        total_time = 0
        for seed in seeds:
            adj_matrix = create_longest_path_problem(size)
            start_time = time.time()
            randomized_hill_climbing_longest_path(adj_matrix, max_iterations, seed)
            end_time = time.time()
            total_time += (end_time - start_time)
        avg_time = total_time / num_runs
        avg_times_per_size.append(avg_time)

    return avg_times_per_size

# Plot wall clock time vs. problem size
def plot_times_vs_problem_size(problem_sizes, avg_times_per_size):
    plt.figure(figsize=(10, 6))
    plt.plot(problem_sizes, avg_times_per_size, marker='o')
    plt.xlabel('Problem Size (Number of Nodes)')
    plt.ylabel('Average Wall Clock Time (seconds)')
    plt.title('Wall Clock Time vs. Problem Size for Randomized Hill Climbing (Longest Path Problem)')
    plt.grid(True)
    plt.show()

# Parameters for Randomized Hill Climbing
problem_sizes = [10, 100, 1000, 5000]  # Different problem sizes
max_iterations = 1000  # Maximum number of iterations
num_runs = 10  # Number of runs
seeds = [i for i in range(num_runs)]  # Generate N seeds

# Run experiments
avg_times_per_size = run_experiments_with_times(problem_sizes, max_iterations, num_runs, seeds)

# Plot wall clock time vs. problem size
plot_times_vs_problem_size(problem_sizes, avg_times_per_size)

# Display the average times
for size, time in zip(problem_sizes, avg_times_per_size):
    print(f'Average wall clock time for problem size {size}: {time:.4f} seconds')

import numpy as np
import random
import matplotlib.pyplot as plt
import time
import mlrose_hiive as mlrose

# Define the Longest Path problem
def create_longest_path_problem(num_nodes):
    np.random.seed(42)
    adj_matrix = np.random.randint(1, 10, size=(num_nodes, num_nodes))
    np.fill_diagonal(adj_matrix, 0)
    return adj_matrix

# Define the fitness function for the Longest Path problem
def longest_path_fitness(path, adj_matrix):
    total_length = sum(adj_matrix[path[i], path[i + 1]] for i in range(len(path) - 1))
    return total_length

# Swap two nodes in the path
def swap_two_nodes(path):
    new_path = path.copy()
    i, j = random.sample(range(len(path)), 2)
    new_path[i], new_path[j] = new_path[j], new_path[i]
    return new_path

# Simulated Annealing algorithm for Longest Path problem
def simulated_annealing_longest_path(adj_matrix, max_iterations, seed, initial_temp, cooling_rate):
    np.random.seed(seed)
    random.seed(seed)

    num_nodes = len(adj_matrix)
    current_path = list(range(num_nodes))
    random.shuffle(current_path)
    current_fitness = longest_path_fitness(current_path, adj_matrix)
    best_path = current_path
    best_fitness = current_fitness

    fitness_history = [current_fitness]
    temperature = initial_temp

    for _ in range(max_iterations):
        new_path = swap_two_nodes(current_path)
        new_fitness = longest_path_fitness(new_path, adj_matrix)
        delta_fitness = new_fitness - current_fitness

        if delta_fitness > 0 or random.random() < np.exp(delta_fitness / temperature):
            current_path = new_path
            current_fitness = new_fitness

            if new_fitness > best_fitness:
                best_path = new_path
                best_fitness = new_fitness

        fitness_history.append(current_fitness)
        temperature *= cooling_rate

    return best_path, best_fitness, fitness_history

# Run experiments with different problem sizes
def run_experiments_with_times(problem_sizes, max_iterations, num_runs, seeds, initial_temp, cooling_rate):
    avg_times_per_size = []

    for size in problem_sizes:
        total_time = 0
        for seed in seeds:
            adj_matrix = create_longest_path_problem(size)
            start_time = time.time()
            simulated_annealing_longest_path(adj_matrix, max_iterations, seed, initial_temp, cooling_rate)
            end_time = time.time()
            total_time += (end_time - start_time)
        avg_time = total_time / num_runs
        avg_times_per_size.append(avg_time)

    return avg_times_per_size

# Plot wall clock time vs. problem size
def plot_times_vs_problem_size(problem_sizes, avg_times_per_size):
    plt.figure(figsize=(10, 6))
    plt.plot(problem_sizes, avg_times_per_size, marker='o')
    plt.xlabel('Problem Size (Number of Nodes)')
    plt.ylabel('Average Wall Clock Time (seconds)')
    plt.title('Wall Clock Time vs. Problem Size for Simulated Annealing (Longest Path Problem)')
    plt.grid(True)
    plt.show()

# Parameters for Simulated Annealing
problem_sizes = [10, 100, 1000, 5000]  # Different problem sizes
max_iterations = 1000  # Maximum number of iterations
num_runs = 10  # Number of runs
seeds = [i for i in range(num_runs)]  # Generate N seeds
initial_temp = 1000  # Initial temperature
cooling_rate = 0.995  # Cooling rate

# Run experiments
avg_times_per_size = run_experiments_with_times(problem_sizes, max_iterations, num_runs, seeds, initial_temp, cooling_rate)

# Plot wall clock time vs. problem size
plot_times_vs_problem_size(problem_sizes, avg_times_per_size)

# Display the average times
for size, time_taken in zip(problem_sizes, avg_times_per_size):
    print(f'Average wall clock time for problem size {size}: {time_taken:.4f} seconds')

import numpy as np
import random
import matplotlib.pyplot as plt
import time
import mlrose_hiive as mlrose

# Define the Longest Path problem
def create_longest_path_problem(num_nodes):
    np.random.seed(42)
    adj_matrix = np.random.randint(1, 10, size=(num_nodes, num_nodes))
    np.fill_diagonal(adj_matrix, 0)
    return adj_matrix

# Define the fitness function for the Longest Path problem
def longest_path_fitness(path, adj_matrix):
    total_length = sum(adj_matrix[path[i], path[i + 1]] for i in range(len(path) - 1))
    return total_length

# Create an initial population
def create_population(pop_size, num_nodes):
    population = []
    for _ in range(pop_size):
        path = list(range(num_nodes))
        random.shuffle(path)
        population.append(path)
    return population

# Select parents based on fitness
def select_parents(population, adj_matrix):
    fitness_scores = [longest_path_fitness(path, adj_matrix) for path in population]
    total_fitness = sum(fitness_scores)
    if total_fitness == 0:
        selection_probs = [1 / len(fitness_scores)] * len(fitness_scores)
    else:
        selection_probs = [score / total_fitness for score in fitness_scores]
    parents = random.choices(population, weights=selection_probs, k=len(population))
    return parents

# Perform crossover between two parents to produce offspring
def crossover(parent1, parent2):
    size = len(parent1)
    start, end = sorted(random.sample(range(size), 2))
    child = [-1] * size
    child[start:end] = parent1[start:end]
    fill_idx = end
    for gene in parent2:
        if gene not in child[start:end]:
            while child[fill_idx] != -1:
                fill_idx = (fill_idx + 1) % size
            child[fill_idx] = gene
    return child

# Perform mutation on a path
def mutate(path, mutation_rate):
    for i in range(len(path)):
        if random.random() < mutation_rate:
            j = random.randint(0, len(path) - 1)
            path[i], path[j] = path[j], path[i]
    return path

# Genetic Algorithm for Longest Path problem
def genetic_algorithm_longest_path(adj_matrix, pop_size, num_generations, mutation_rate, seed):
    np.random.seed(seed)
    random.seed(seed)

    num_nodes = len(adj_matrix)
    population = create_population(pop_size, num_nodes)
    best_path = max(population, key=lambda path: longest_path_fitness(path, adj_matrix))
    best_fitness = longest_path_fitness(best_path, adj_matrix)

    fitness_history = [best_fitness]

    for _ in range(num_generations):
        parents = select_parents(population, adj_matrix)
        population = [mutate(crossover(parents[i], parents[len(parents) - i - 1]), mutation_rate) for i in range(len(parents))]
        current_best_path = max(population, key=lambda path: longest_path_fitness(path, adj_matrix))
        current_best_fitness = longest_path_fitness(current_best_path, adj_matrix)
        if current_best_fitness > best_fitness:
            best_path = current_best_path
            best_fitness = current_best_fitness
        fitness_history.append(best_fitness)

    return best_path, best_fitness, fitness_history

# Run experiments with different problem sizes
def run_experiments_with_times(problem_sizes, pop_size, num_generations, mutation_rate, num_runs, seeds):
    avg_times_per_size = []

    for size in problem_sizes:
        total_time = 0
        for seed in seeds:
            adj_matrix = create_longest_path_problem(size)
            start_time = time.time()
            genetic_algorithm_longest_path(adj_matrix, pop_size, num_generations, mutation_rate, seed)
            end_time = time.time()
            total_time += (end_time - start_time)
        avg_time = total_time / num_runs
        avg_times_per_size.append(avg_time)

    return avg_times_per_size

# Plot wall clock time vs. problem size
def plot_times_vs_problem_size(problem_sizes, avg_times_per_size):
    plt.figure(figsize=(10, 6))
    plt.plot(problem_sizes, avg_times_per_size, marker='o')
    plt.xlabel('Problem Size (Number of Nodes)')
    plt.ylabel('Average Wall Clock Time (seconds)')
    plt.title('Wall Clock Time vs. Problem Size for Genetic Algorithm (Longest Path Problem)')
    plt.grid(True)
    plt.show()

# Parameters for Genetic Algorithm
problem_sizes = [ 100,1000,5000]  # Different problem sizes
pop_size = 100  # Population size
num_generations = 100  # Number of generations
mutation_rate = 0.01  # Mutation rate
num_runs = 10  # Number of runs
seeds = [i for i in range(num_runs)]  # Generate N seeds

# Run experiments
avg_times_per_size = run_experiments_with_times(problem_sizes, pop_size, num_generations, mutation_rate, num_runs, seeds)

# Plot wall clock time vs. problem size
plot_times_vs_problem_size(problem_sizes, avg_times_per_size)

# Display the average times
for size, time_taken in zip(problem_sizes, avg_times_per_size):
    print(f'Average wall clock time for problem size {size}: {time_taken:.4f} seconds')