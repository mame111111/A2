# -*- coding: utf-8 -*-
"""Untitled13.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1k2InPuV-Ip9npwQGZY7mG9zL9DME2jdR
"""

import numpy as np
import random
import matplotlib.pyplot as plt
import mlrose_hiive as mlrose

# Define the knapsack problem
def create_knapsack_problem(num_items):
    np.random.seed(42)
    values = np.random.randint(1, 100, num_items)
    weights = np.random.randint(1, 100, num_items)
    capacity = int(0.5 * num_items * 50)  # Adjust capacity as needed
    return values, weights, capacity

# Define the fitness function for the knapsack problem
def knapsack_fitness(solution, values, weights, capacity):
    total_value = np.sum(solution * values)
    total_weight = np.sum(solution * weights)
    if total_weight > capacity:
        return 0  # Penalize solutions that exceed capacity
    return total_value

# Generate a neighbor solution by flipping a random bit
def flip_random_bit(solution):
    new_solution = solution.copy()
    index = random.randint(0, len(solution) - 1)
    new_solution[index] = 1 - new_solution[index]
    return new_solution

# Hill climbing algorithm for the knapsack problem
def hill_climbing_knapsack(values, weights, capacity, max_iterations, seed):
    np.random.seed(seed)
    random.seed(seed)

    num_items = len(values)
    current_solution = np.random.randint(0, 2, num_items)
    current_fitness = knapsack_fitness(current_solution, values, weights, capacity)

    fitness_history = [current_fitness]

    for _ in range(max_iterations):
        new_solution = flip_random_bit(current_solution)
        new_fitness = knapsack_fitness(new_solution, values, weights, capacity)

        if new_fitness > current_fitness:
            current_solution = new_solution
            current_fitness = new_fitness

        fitness_history.append(current_fitness)

    return current_solution, current_fitness, fitness_history

# Run experiments with multiple seeds
def run_experiments(num_items, max_iterations, num_runs, seeds):
    all_fitness_histories = []
    values, weights, capacity = create_knapsack_problem(num_items)

    for seed in seeds:
        _, _, fitness_history = hill_climbing_knapsack(values, weights, capacity, max_iterations, seed)
        all_fitness_histories.append(fitness_history)

    return np.array(all_fitness_histories)

# Plot the best fitness with variance
def plot_best_fitness(fitness_histories):
    best_fitness = np.max(fitness_histories, axis=0)
    avg_fitness = np.mean(fitness_histories, axis=0)
    std_fitness = np.std(fitness_histories, axis=0)

    plt.figure(figsize=(10, 6))
    plt.step(range(len(best_fitness)), best_fitness, label='Best Fitness', where='post')
    plt.fill_between(range(len(avg_fitness)), avg_fitness - std_fitness, avg_fitness + std_fitness, alpha=0.2, label='Variance', step='post')
    plt.xlabel('Iteration')
    plt.ylabel('Fitness (Total Value)')
    plt.title('RHC - Best Fitness (Total Value) vs. Iteration with Variance')
    plt.legend()
    plt.grid(True)
    plt.show()

# Parameters
num_items = 100  # Number of items
max_iterations = 5000  # Maximum number of iterations
num_runs = 50  # Number of runs
seeds = [i for i in range(num_runs)]  # Generate N seeds

# Run experiments
all_fitness_histories = run_experiments(num_items, max_iterations, num_runs, seeds)

# Plot best fitness
plot_best_fitness(all_fitness_histories)

import numpy as np
import random
import matplotlib.pyplot as plt
import mlrose_hiive as mlrose

# Define the knapsack problem
def create_knapsack_problem(num_items):
    np.random.seed(42)
    values = np.random.randint(1, 100, num_items)
    weights = np.random.randint(1, 100, num_items)
    capacity = int(0.5 * num_items * 50)  # Adjust capacity as needed
    return values, weights, capacity

# Define the fitness function for the knapsack problem
def knapsack_fitness(solution, values, weights, capacity):
    total_value = np.sum(solution * values)
    total_weight = np.sum(solution * weights)
    if total_weight > capacity:
        return 0  # Penalize solutions that exceed capacity
    return total_value

# Generate a neighbor solution by flipping a random bit
def flip_random_bit(solution):
    new_solution = solution.copy()
    index = random.randint(0, len(solution) - 1)
    new_solution[index] = 1 - new_solution[index]
    return new_solution

# Simulated Annealing algorithm for the knapsack problem
def simulated_annealing_knapsack(values, weights, capacity, max_iterations, seed, initial_temp, cooling_rate):
    np.random.seed(seed)
    random.seed(seed)

    num_items = len(values)
    current_solution = np.random.randint(0, 2, num_items)
    current_fitness = knapsack_fitness(current_solution, values, weights, capacity)
    best_solution = current_solution
    best_fitness = current_fitness

    fitness_history = [current_fitness]
    temperature = initial_temp

    for _ in range(max_iterations):
        new_solution = flip_random_bit(current_solution)
        new_fitness = knapsack_fitness(new_solution, values, weights, capacity)
        delta_fitness = new_fitness - current_fitness

        if delta_fitness > 0 or random.random() < np.exp(delta_fitness / temperature):
            current_solution = new_solution
            current_fitness = new_fitness

            if new_fitness > best_fitness:
                best_solution = new_solution
                best_fitness = new_fitness

        fitness_history.append(current_fitness)
        temperature *= cooling_rate

    return best_solution, best_fitness, fitness_history

# Run experiments with multiple seeds
def run_experiments(num_items, max_iterations, num_runs, seeds, initial_temp, cooling_rate):
    all_fitness_histories = []
    values, weights, capacity = create_knapsack_problem(num_items)

    for seed in seeds:
        _, _, fitness_history = simulated_annealing_knapsack(values, weights, capacity, max_iterations, seed, initial_temp, cooling_rate)
        all_fitness_histories.append(fitness_history)

    return np.array(all_fitness_histories)

# Plot the best fitness with variance
def plot_best_fitness(fitness_histories, title):
    best_fitness = np.max(fitness_histories, axis=0)
    avg_fitness = np.mean(fitness_histories, axis=0)
    std_fitness = np.std(fitness_histories, axis=0)

    plt.figure(figsize=(10, 6))
    plt.step(range(len(best_fitness)), best_fitness, label='Best Fitness', where='post')
    plt.fill_between(range(len(avg_fitness)), avg_fitness - std_fitness, avg_fitness + std_fitness, alpha=0.2, label='Variance', step='post')
    plt.xlabel('Iteration')
    plt.ylabel('Fitness (Total Value)')
    plt.title(title)
    plt.legend()
    plt.grid(True)
    plt.show()

# Parameters for tuning
num_items = 100  # Number of items
max_iterations = 5000  # Maximum number of iterations
num_runs = 50  # Number of runs
seeds = [i for i in range(num_runs)]  # Generate N seeds

# Different parameters to test
parameter_sets = [
    {'initial_temp': 1000, 'cooling_rate': 0.995},
    {'initial_temp': 500, 'cooling_rate': 0.99},
    {'initial_temp': 2000, 'cooling_rate': 0.998},
    {'initial_temp': 1000, 'cooling_rate': 0.99},
    {'initial_temp': 1500, 'cooling_rate': 0.995},
]

# Run experiments for each parameter set
for params in parameter_sets:
    initial_temp = params['initial_temp']
    cooling_rate = params['cooling_rate']
    fitness_histories = run_experiments(num_items, max_iterations, num_runs, seeds, initial_temp, cooling_rate)
    plot_best_fitness(fitness_histories, f'Best Fitness (Initial Temp: {initial_temp}, Cooling Rate: {cooling_rate})')

import numpy as np
import random
import matplotlib.pyplot as plt
import mlrose_hiive as mlrose

# Define the knapsack problem
def create_knapsack_problem(num_items):
    np.random.seed(42)
    values = np.random.randint(1, 100, num_items)
    weights = np.random.randint(1, 100, num_items)
    capacity = int(0.5 * num_items * 50)  # Adjust capacity as needed
    return values, weights, capacity

# Define the fitness function for the knapsack problem
def knapsack_fitness(solution, values, weights, capacity):
    total_value = np.sum(solution * values)
    total_weight = np.sum(solution * weights)
    if total_weight > capacity:
        return 0  # Penalize solutions that exceed capacity
    return total_value

# Generate a neighbor solution by flipping a random bit
def flip_random_bit(solution):
    new_solution = solution.copy()
    index = random.randint(0, len(solution) - 1)
    new_solution[index] = 1 - new_solution[index]
    return new_solution

# Simulated Annealing algorithm for the knapsack problem
def simulated_annealing_knapsack(values, weights, capacity, max_iterations, seed, initial_temp, cooling_rate):
    np.random.seed(seed)
    random.seed(seed)

    num_items = len(values)
    current_solution = np.random.randint(0, 2, num_items)
    current_fitness = knapsack_fitness(current_solution, values, weights, capacity)
    best_solution = current_solution
    best_fitness = current_fitness

    fitness_history = [current_fitness]
    temperature = initial_temp

    for _ in range(max_iterations):
        new_solution = flip_random_bit(current_solution)
        new_fitness = knapsack_fitness(new_solution, values, weights, capacity)
        delta_fitness = new_fitness - current_fitness

        if delta_fitness > 0 or random.random() < np.exp(delta_fitness / temperature):
            current_solution = new_solution
            current_fitness = new_fitness

            if new_fitness > best_fitness:
                best_solution = new_solution
                best_fitness = new_fitness

        fitness_history.append(current_fitness)
        temperature *= cooling_rate

    return best_solution, best_fitness, fitness_history

# Run experiments with multiple seeds
def run_experiments(num_items, max_iterations, num_runs, seeds, initial_temp, cooling_rate):
    all_fitness_histories = []
    values, weights, capacity = create_knapsack_problem(num_items)

    for seed in seeds:
        _, _, fitness_history = simulated_annealing_knapsack(values, weights, capacity, max_iterations, seed, initial_temp, cooling_rate)
        all_fitness_histories.append(fitness_history)

    return np.array(all_fitness_histories)

# Plot fitness vs. iteration for different initial temperatures
def plot_fitness_vs_iteration_initial_temp(initial_temps, num_items, max_iterations, num_runs, seeds, cooling_rate):
    plt.figure(figsize=(10, 6))
    for initial_temp in initial_temps:
        fitness_histories = run_experiments(num_items, max_iterations, num_runs, seeds, initial_temp, cooling_rate)
        avg_fitness = np.mean(fitness_histories, axis=0)
        plt.plot(avg_fitness, label=f'Initial Temp: {initial_temp}')

    plt.xlabel('Iteration')
    plt.ylabel('Fitness (Total Value)')
    plt.title('SA - Fitness vs. Iteration for Different Initial Temperatures')
    plt.legend()
    plt.grid(True)
    plt.show()

# Plot fitness vs. iteration for different cooling rates
def plot_fitness_vs_iteration_cooling_rate(cooling_rates, num_items, max_iterations, num_runs, seeds, initial_temp):
    plt.figure(figsize=(10, 6))
    for cooling_rate in cooling_rates:
        fitness_histories = run_experiments(num_items, max_iterations, num_runs, seeds, initial_temp, cooling_rate)
        avg_fitness = np.mean(fitness_histories, axis=0)
        plt.plot(avg_fitness, label=f'Cooling Rate: {cooling_rate}')

    plt.xlabel('Iteration')
    plt.ylabel('Fitness (Total Value)')
    plt.title('SA- Fitness vs. Iteration for Different Cooling Rates')
    plt.legend()
    plt.grid(True)
    plt.show()

# Parameters
num_items = 100  # Number of items
max_iterations = 1000  # Maximum number of iterations
num_runs = 10  # Number of runs
seeds = [i for i in range(num_runs)]  # Generate N seeds

# Different initial temperatures to test
initial_temps = [500, 1000, 1500, 2000]

# Plot fitness vs. iteration for different initial temperatures
cooling_rate = 0.995  # Use a fixed cooling rate for this plot
plot_fitness_vs_iteration_initial_temp(initial_temps, num_items, max_iterations, num_runs, seeds, cooling_rate)

# Different cooling rates to test
cooling_rates = [0.99, 0.995, 0.998, 0.999]

# Use the best initial temperature (you can choose based on the previous plot)
best_initial_temp = 1000

# Plot fitness vs. iteration for different cooling rates
plot_fitness_vs_iteration_cooling_rate(cooling_rates, num_items, max_iterations, num_runs, seeds, best_initial_temp)

import numpy as np
import random
import matplotlib.pyplot as plt
# import mlrose_hiive as mlrose

# Define the knapsack problem
def create_knapsack_problem(num_items):
    np.random.seed(42)
    values = np.random.randint(1, 100, num_items)
    weights = np.random.randint(1, 100, num_items)
    capacity = int(0.5 * num_items * 50)  # Adjust capacity as needed
    return values, weights, capacity

# Define the fitness function for the knapsack problem
def knapsack_fitness(solution, values, weights, capacity):
    total_value = np.sum(solution * values)
    total_weight = np.sum(solution * weights)
    if total_weight > capacity:
        return 0  # Penalize solutions that exceed capacity
    return total_value

# Generate a neighbor solution by flipping a random bit
def flip_random_bit(solution):
    new_solution = solution.copy()
    index = random.randint(0, len(solution) - 1)
    new_solution[index] = 1 - new_solution[index]
    return new_solution

# Simulated Annealing algorithm for the knapsack problem
def simulated_annealing_knapsack(values, weights, capacity, max_iterations, seed, initial_temp, cooling_rate):
    np.random.seed(seed)
    random.seed(seed)

    num_items = len(values)
    current_solution = np.random.randint(0, 2, num_items)
    current_fitness = knapsack_fitness(current_solution, values, weights, capacity)
    best_solution = current_solution
    best_fitness = current_fitness

    fitness_history = [current_fitness]
    temperature = initial_temp

    for _ in range(max_iterations):
        new_solution = flip_random_bit(current_solution)
        new_fitness = knapsack_fitness(new_solution, values, weights, capacity)
        delta_fitness = new_fitness - current_fitness

        if delta_fitness > 0 or random.random() < np.exp(delta_fitness / temperature):
            current_solution = new_solution
            current_fitness = new_fitness

            if new_fitness > best_fitness:
                best_solution = new_solution
                best_fitness = new_fitness

        fitness_history.append(current_fitness)
        temperature *= cooling_rate

    return best_solution, best_fitness, fitness_history

# Run experiments with multiple seeds
def run_experiments(num_items, max_iterations, num_runs, seeds, initial_temp, cooling_rate):
    all_fitness_histories = []
    values, weights, capacity = create_knapsack_problem(num_items)

    for seed in seeds:
        _, _, fitness_history = simulated_annealing_knapsack(values, weights, capacity, max_iterations, seed, initial_temp, cooling_rate)
        all_fitness_histories.append(fitness_history)

    return np.array(all_fitness_histories)

# Plot fitness vs. iteration for different initial temperatures
def plot_fitness_vs_iteration_initial_temp(initial_temps, num_items, max_iterations, num_runs, seeds, cooling_rate):
    plt.figure(figsize=(10, 6))
    for initial_temp in initial_temps:
        fitness_histories = run_experiments(num_items, max_iterations, num_runs, seeds, initial_temp, cooling_rate)
        avg_fitness = np.mean(fitness_histories, axis=0)
        plt.plot(avg_fitness, label=f'Initial Temp: {initial_temp}')

    plt.xlabel('Iteration')
    plt.ylabel('Fitness (Total Value)')
    plt.title('SA - Knapsack')
    plt.legend()
    plt.grid(True)
    plt.show()



# Parameters
num_items = 100  # Number of items
max_iterations = 1000  # Maximum number of iterations
num_runs = 10  # Number of runs
seeds = [i for i in range(num_runs)]  # Generate N seeds

# Different initial temperatures to test
initial_temps = [500]

# Plot fitness vs. iteration for different initial temperatures
cooling_rate = 0.995  # Use a fixed cooling rate for this plot
plot_fitness_vs_iteration_initial_temp(initial_temps, num_items, max_iterations, num_runs, seeds, cooling_rate)

# Different cooling rates to test
cooling_rates = [0.99]

# Use the best initial temperature (you can choose based on the previous plot)
best_initial_temp = 1000

import numpy as np
import random
import matplotlib.pyplot as plt
import mlrose_hiive as mlrose

# Define the knapsack problem
def create_knapsack_problem(num_items):
    np.random.seed(42)
    values = np.random.randint(1, 100, num_items)
    weights = np.random.randint(1, 100, num_items)
    capacity = int(0.5 * num_items * 50)  # Adjust capacity as needed
    return values, weights, capacity

# Define the fitness function for the knapsack problem
def knapsack_fitness(solution, values, weights, capacity):
    total_value = np.sum(solution * values)
    total_weight = np.sum(solution * weights)
    if total_weight > capacity:
        return 0  # Penalize solutions that exceed capacity
    return total_value

# Create an initial population
def create_population(pop_size, num_items):
    population = []
    for _ in range(pop_size):
        solution = np.random.randint(0, 2, num_items)
        population.append(solution)
    return population

# Select parents based on fitness
def select_parents(population, values, weights, capacity):
    fitness_scores = [knapsack_fitness(solution, values, weights, capacity) for solution in population]
    total_fitness = sum(fitness_scores)
    if total_fitness == 0:
        selection_probs = [1 / len(fitness_scores)] * len(fitness_scores)
    else:
        selection_probs = [score / total_fitness for score in fitness_scores]
    parents = random.choices(population, weights=selection_probs, k=len(population))
    return parents

# Perform crossover between two parents to produce offspring
def crossover(parent1, parent2):
    size = len(parent1)
    start, end = sorted(random.sample(range(size), 2))
    child = np.zeros(size, dtype=int)
    child[start:end] = parent1[start:end]
    fill_idx = end
    for gene in parent2:
        if gene not in child[start:end]:
            while child[fill_idx] != 0:
                fill_idx = (fill_idx + 1) % size
            child[fill_idx] = gene
    return child

# Perform mutation on a solution
def mutate(solution, mutation_rate):
    for i in range(len(solution)):
        if random.random() < mutation_rate:
            solution[i] = 1 - solution[i]
    return solution

# Genetic Algorithm for Knapsack problem
def genetic_algorithm_knapsack(values, weights, capacity, pop_size, num_generations, mutation_rate, seed):
    np.random.seed(seed)
    random.seed(seed)

    num_items = len(values)
    population = create_population(pop_size, num_items)
    best_solution = max(population, key=lambda solution: knapsack_fitness(solution, values, weights, capacity))
    best_fitness = knapsack_fitness(best_solution, values, weights, capacity)

    fitness_history = [best_fitness]

    for _ in range(num_generations):
        parents = select_parents(population, values, weights, capacity)
        population = [mutate(crossover(parents[i], parents[len(parents) - i - 1]), mutation_rate) for i in range(len(parents))]
        current_best_solution = max(population, key=lambda solution: knapsack_fitness(solution, values, weights, capacity))
        current_best_fitness = knapsack_fitness(current_best_solution, values, weights, capacity)
        if current_best_fitness > best_fitness:
            best_solution = current_best_solution
            best_fitness = current_best_fitness
        fitness_history.append(best_fitness)

    return best_solution, best_fitness, fitness_history

# Run experiments with multiple seeds
def run_experiments(num_items, pop_size, num_generations, mutation_rate, num_runs, seeds):
    all_fitness_histories = []
    values, weights, capacity = create_knapsack_problem(num_items)

    for seed in seeds:
        _, _, fitness_history = genetic_algorithm_knapsack(values, weights, capacity, pop_size, num_generations, mutation_rate, seed)
        all_fitness_histories.append(fitness_history)

    return np.array(all_fitness_histories)

# Plot the best fitness with variance
def plot_best_fitness(fitness_histories, title):
    best_fitness = np.max(fitness_histories, axis=0)
    avg_fitness = np.mean(fitness_histories, axis=0)
    std_fitness = np.std(fitness_histories, axis=0)

    plt.figure(figsize=(10, 6))
    plt.step(range(len(best_fitness)), best_fitness, label='Best Fitness', where='post')
    plt.fill_between(range(len(avg_fitness)), avg_fitness - std_fitness, avg_fitness + std_fitness, alpha=0.2, label='Variance', step='post')
    plt.xlabel('Iteration')
    plt.ylabel('Fitness (Total Value)')
    plt.title(title)
    plt.legend()
    plt.grid(True)
    plt.show()

# Parameters for Genetic Algorithm
num_items = 100  # Number of items
pop_size = 100  # Population size
num_generations = 5000  # Number of generations
mutation_rate = 100  # Mutation rate
num_runs = 50  # Number of runs
seeds = [i for i in range(num_runs)]  # Generate N seeds

# Run experiments
all_fitness_histories = run_experiments(num_items, pop_size, num_generations, mutation_rate, num_runs, seeds)

# Plot best fitness
plot_best_fitness(all_fitness_histories, 'Best Fitness (Genetic Algorithm)')

import numpy as np
import random
import matplotlib.pyplot as plt
import mlrose_hiive as mlrose

# Define the knapsack problem
def create_knapsack_problem(num_items):
    np.random.seed(42)
    values = np.random.randint(1, 100, num_items)
    weights = np.random.randint(1, 100, num_items)
    capacity = int(0.5 * num_items * 50)  # Adjust capacity as needed
    return values, weights, capacity

# Define the fitness function for the knapsack problem
def knapsack_fitness(solution, values, weights, capacity):
    total_value = np.sum(solution * values)
    total_weight = np.sum(solution * weights)
    if total_weight > capacity:
        return 0  # Penalize solutions that exceed capacity
    return total_value

# Create an initial population
def create_population(pop_size, num_items):
    population = []
    for _ in range(pop_size):
        solution = np.random.randint(0, 2, num_items)
        population.append(solution)
    return population

# Select parents based on fitness
def select_parents(population, values, weights, capacity):
    fitness_scores = [knapsack_fitness(solution, values, weights, capacity) for solution in population]
    total_fitness = sum(fitness_scores)
    if total_fitness == 0:
        selection_probs = [1 / len(fitness_scores)] * len(fitness_scores)
    else:
        selection_probs = [score / total_fitness for score in fitness_scores]
    parents = random.choices(population, weights=selection_probs, k=len(population))
    return parents

# Perform crossover between two parents to produce offspring
def crossover(parent1, parent2):
    size = len(parent1)
    start, end = sorted(random.sample(range(size), 2))
    child = np.zeros(size, dtype=int)
    child[start:end] = parent1[start:end]
    fill_idx = end
    for gene in parent2:
        if gene not in child[start:end]:
            while child[fill_idx] != 0:
                fill_idx = (fill_idx + 1) % size
            child[fill_idx] = gene
    return child

# Perform mutation on a solution
def mutate(solution, mutation_rate):
    for i in range(len(solution)):
        if random.random() < mutation_rate:
            solution[i] = 1 - solution[i]
    return solution

# Genetic Algorithm for Knapsack problem
def genetic_algorithm_knapsack(values, weights, capacity, pop_size, num_generations, mutation_rate, seed):
    np.random.seed(seed)
    random.seed(seed)

    num_items = len(values)
    population = create_population(pop_size, num_items)
    best_solution = max(population, key=lambda solution: knapsack_fitness(solution, values, weights, capacity))
    best_fitness = knapsack_fitness(best_solution, values, weights, capacity)

    fitness_history = [best_fitness]

    for _ in range(num_generations):
        parents = select_parents(population, values, weights, capacity)
        population = [mutate(crossover(parents[i], parents[len(parents) - i - 1]), mutation_rate) for i in range(len(parents))]
        current_best_solution = max(population, key=lambda solution: knapsack_fitness(solution, values, weights, capacity))
        current_best_fitness = knapsack_fitness(current_best_solution, values, weights, capacity)
        if current_best_fitness > best_fitness:
            best_solution = current_best_solution
            best_fitness = current_best_fitness
        fitness_history.append(best_fitness)

    return best_solution, best_fitness, fitness_history

# Run experiments with multiple seeds
def run_experiments(num_items, pop_size, num_generations, mutation_rate, num_runs, seeds):
    all_fitness_histories = []
    values, weights, capacity = create_knapsack_problem(num_items)

    for seed in seeds:
        _, _, fitness_history = genetic_algorithm_knapsack(values, weights, capacity, pop_size, num_generations, mutation_rate, seed)
        all_fitness_histories.append(fitness_history)

    return np.array(all_fitness_histories)

# Plot fitness vs. iteration for different mutation rates
def plot_fitness_vs_iteration_mutation_rate(mutation_rates, num_items, pop_size, num_generations, num_runs, seeds):
    plt.figure(figsize=(10, 6))
    for mutation_rate in mutation_rates:
        fitness_histories = run_experiments(num_items, pop_size, num_generations, mutation_rate, num_runs, seeds)
        avg_fitness = np.mean(fitness_histories, axis=0)
        plt.plot(avg_fitness, label=f'Mutation Rate: {mutation_rate}')

    plt.xlabel('Iteration')
    plt.ylabel('Fitness (Total Value)')
    plt.title('Fitness vs. Iteration for Different Mutation Rates')
    plt.legend()
    plt.grid(True)
    plt.show()

# Parameters for Genetic Algorithm
num_items = 100  # Number of items
pop_size = 100  # Population size
num_generations = 100  # Number of generations (reduced for faster computation)
num_runs = 10  # Number of runs (reduced for faster computation)
seeds = [i for i in range(num_runs)]  # Generate N seeds

# Different mutation rates to test
mutation_rates = [0.001, 0.01, 0.1, 1, 10, 100]

# Plot fitness vs. iteration for different mutation rates
plot_fitness_vs_iteration_mutation_rate(mutation_rates, num_items, pop_size, num_generations, num_runs, seeds)

import numpy as np
import random
import matplotlib.pyplot as plt
import pandas as pd
import mlrose_hiive as mlrose

# Define the Knapsack problem
def create_knapsack_problem(num_items):
    np.random.seed(42)
    weights = np.random.randint(1, 100, size=num_items)
    values = np.random.randint(1, 100, size=num_items)
    capacity = int(num_items * 50 / 2)  # Adjust capacity as needed
    return weights, values, capacity

# Define the fitness function for the Knapsack problem
def knapsack_fitness(solution, weights, values, capacity):
    total_weight = np.sum(solution * weights)
    if total_weight > capacity:
        return 0
    total_value = np.sum(solution * values)
    return total_value

# Swap two items in the solution
def swap_two_items(solution):
    new_solution = solution.copy()
    i, j = random.sample(range(len(solution)), 2)
    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]
    return new_solution

# Randomized Hill Climbing algorithm for Knapsack problem
def randomized_hill_climbing_knapsack(weights, values, capacity, max_iterations, seed):
    np.random.seed(seed)
    random.seed(seed)

    num_items = len(weights)
    current_solution = np.random.randint(2, size=num_items)
    current_fitness = knapsack_fitness(current_solution, weights, values, capacity)

    fitness_history = [current_fitness]

    for _ in range(max_iterations):
        new_solution = swap_two_items(current_solution)
        new_fitness = knapsack_fitness(new_solution, weights, values, capacity)

        if new_fitness > current_fitness:
            current_solution = new_solution
            current_fitness = new_fitness

        fitness_history.append(current_fitness)

    return current_solution, current_fitness, fitness_history

# Run experiments with different problem sizes
def run_experiments_with_problem_sizes(problem_sizes, max_iterations, num_runs, seeds):
    avg_fitness_per_size = []
    fitness_results_per_size = []

    for size in problem_sizes:
        fitness_results = []
        for seed in seeds:
            weights, values, capacity = create_knapsack_problem(size)
            _, best_fitness, _ = randomized_hill_climbing_knapsack(weights, values, capacity, max_iterations, seed)
            fitness_results.append(best_fitness)
        avg_fitness_per_size.append(np.mean(fitness_results))
        fitness_results_per_size.append(fitness_results)

    return avg_fitness_per_size, fitness_results_per_size

# Plot fitness vs. problem size
def plot_fitness_vs_problem_size(problem_sizes, avg_fitness_per_size):
    plt.figure(figsize=(10, 6))
    plt.plot(problem_sizes, avg_fitness_per_size, marker='o')
    plt.xlabel('Problem Size (Number of Items)')
    plt.ylabel('Fitness (Total Value)')
    plt.title('Fitness vs. Problem Size for Randomized Hill Climbing (Knapsack Problem)')
    plt.grid(True)
    plt.show()

# Parameters for Randomized Hill Climbing
problem_sizes = [10, 100, 1000, 5000]  # Different problem sizes
max_iterations = 1000  # Maximum number of iterations
num_runs = 10  # Number of runs
seeds = [i for i in range(num_runs)]  # Generate N seeds

# Run experiments
avg_fitness_per_size, fitness_results_per_size = run_experiments_with_problem_sizes(problem_sizes, max_iterations, num_runs, seeds)

# Plot fitness vs. problem size
plot_fitness_vs_problem_size(problem_sizes, avg_fitness_per_size)

# Display fitness results in a table
fitness_results_df = pd.DataFrame(fitness_results_per_size, index=problem_sizes).T
fitness_results_df.columns = [f'Problem Size {size}' for size in problem_sizes]
fitness_results_df.index.name = 'Run'
print(fitness_results_df)

import numpy as np
import random
import matplotlib.pyplot as plt
import pandas as pd
import mlrose_hiive as mlrose

# Define the Knapsack problem
def create_knapsack_problem(num_items):
    np.random.seed(42)
    weights = np.random.randint(1, 100, size=num_items)
    values = np.random.randint(1, 100, size=num_items)
    capacity = int(num_items * 50 / 2)  # Adjust capacity as needed
    return weights, values, capacity

# Define the fitness function for the Knapsack problem
def knapsack_fitness(solution, weights, values, capacity):
    total_weight = np.sum(solution * weights)
    if total_weight > capacity:
        return 0
    total_value = np.sum(solution * values)
    return total_value

# Swap two items in the solution
def swap_two_items(solution):
    new_solution = solution.copy()
    i, j = random.sample(range(len(solution)), 2)
    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]
    return new_solution

# Simulated Annealing algorithm for Knapsack problem
def simulated_annealing_knapsack(weights, values, capacity, max_iterations, seed, initial_temp, cooling_rate):
    np.random.seed(seed)
    random.seed(seed)

    num_items = len(weights)
    current_solution = np.random.randint(2, size=num_items)
    current_fitness = knapsack_fitness(current_solution, weights, values, capacity)
    best_solution = current_solution
    best_fitness = current_fitness

    fitness_history = [current_fitness]
    temperature = initial_temp

    for _ in range(max_iterations):
        new_solution = swap_two_items(current_solution)
        new_fitness = knapsack_fitness(new_solution, weights, values, capacity)
        delta_fitness = new_fitness - current_fitness

        if delta_fitness > 0 or random.random() < np.exp(delta_fitness / temperature):
            current_solution = new_solution
            current_fitness = new_fitness

            if new_fitness > best_fitness:
                best_solution = new_solution
                best_fitness = new_fitness

        fitness_history.append(current_fitness)
        temperature *= cooling_rate

    return best_solution, best_fitness, fitness_history

# Run experiments with different problem sizes
def run_experiments_with_problem_sizes(problem_sizes, max_iterations, num_runs, seeds, initial_temp, cooling_rate):
    avg_fitness_per_size = []
    fitness_results_per_size = []

    for size in problem_sizes:
        fitness_results = []
        for seed in seeds:
            weights, values, capacity = create_knapsack_problem(size)
            _, best_fitness, _ = simulated_annealing_knapsack(weights, values, capacity, max_iterations, seed, initial_temp, cooling_rate)
            fitness_results.append(best_fitness)
        avg_fitness_per_size.append(np.mean(fitness_results))
        fitness_results_per_size.append(fitness_results)

    return avg_fitness_per_size, fitness_results_per_size

# Plot fitness vs. problem size
def plot_fitness_vs_problem_size(problem_sizes, avg_fitness_per_size):
    plt.figure(figsize=(10, 6))
    plt.plot(problem_sizes, avg_fitness_per_size, marker='o')
    plt.xlabel('Problem Size (Number of Items)')
    plt.ylabel('Fitness (Total Value)')
    plt.title('Fitness vs. Problem Size for Simulated Annealing (Knapsack Problem)')
    plt.grid(True)
    plt.show()

# Parameters for Simulated Annealing
problem_sizes = [10, 100, 1000, 5000]  # Different problem sizes
max_iterations = 1000  # Maximum number of iterations
num_runs = 10  # Number of runs
seeds = [i for i in range(num_runs)]  # Generate N seeds
initial_temp = 1000  # Initial temperature
cooling_rate = 0.995  # Cooling rate

# Run experiments
avg_fitness_per_size, fitness_results_per_size = run_experiments_with_problem_sizes(problem_sizes, max_iterations, num_runs, seeds, initial_temp, cooling_rate)

# Plot fitness vs. problem size
plot_fitness_vs_problem_size(problem_sizes, avg_fitness_per_size)

# Display fitness results in a table
fitness_results_df = pd.DataFrame(fitness_results_per_size, index=problem_sizes).T
fitness_results_df.columns = [f'Problem Size {size}' for size in problem_sizes]
fitness_results_df.index.name = 'Run'
print(fitness_results_df)

import numpy as np
import random
import matplotlib.pyplot as plt
import pandas as pd
import mlrose_hiive as mlrose

# Define the Knapsack problem
def create_knapsack_problem(num_items):
    np.random.seed(42)
    weights = np.random.randint(1, 100, size=num_items)
    values = np.random.randint(1, 100, size=num_items)
    capacity = int(num_items * 50 / 2)  # Adjust capacity as needed
    return weights, values, capacity

# Define the fitness function for the Knapsack problem
def knapsack_fitness(solution, weights, values, capacity):
    total_weight = np.sum(solution * weights)
    if total_weight > capacity:
        return 0
    total_value = np.sum(solution * values)
    return total_value

# Create an initial population
def create_population(pop_size, num_items):
    population = []
    for _ in range(pop_size):
        solution = np.random.randint(2, size=num_items)
        population.append(solution)
    return population

# Select parents based on fitness
def select_parents(population, weights, values, capacity):
    fitness_scores = [knapsack_fitness(solution, weights, values, capacity) for solution in population]
    total_fitness = sum(fitness_scores)
    if total_fitness == 0:
        selection_probs = [1 / len(fitness_scores)] * len(fitness_scores)
    else:
        selection_probs = [score / total_fitness for score in fitness_scores]
    parents = random.choices(population, weights=selection_probs, k=len(population))
    return parents

# Perform crossover between two parents to produce offspring
def crossover(parent1, parent2):
    size = len(parent1)
    start, end = sorted(random.sample(range(size), 2))
    child = np.copy(parent1)
    child[start:end] = parent2[start:end]
    return child

# Perform mutation on a solution
def mutate(solution, mutation_rate):
    for i in range(len(solution)):
        if random.random() < mutation_rate:
            solution[i] = 1 - solution[i]
    return solution

# Genetic Algorithm for Knapsack problem
def genetic_algorithm_knapsack(weights, values, capacity, pop_size, num_generations, mutation_rate, seed):
    np.random.seed(seed)
    random.seed(seed)

    num_items = len(weights)
    population = create_population(pop_size, num_items)
    best_solution = max(population, key=lambda solution: knapsack_fitness(solution, weights, values, capacity))
    best_fitness = knapsack_fitness(best_solution, weights, values, capacity)

    fitness_history = [best_fitness]

    for _ in range(num_generations):
        parents = select_parents(population, weights, values, capacity)
        population = [mutate(crossover(parents[i], parents[len(parents) - i - 1]), mutation_rate) for i in range(len(parents))]
        current_best_solution = max(population, key=lambda solution: knapsack_fitness(solution, weights, values, capacity))
        current_best_fitness = knapsack_fitness(current_best_solution, weights, values, capacity)
        if current_best_fitness > best_fitness:
            best_solution = current_best_solution
            best_fitness = current_best_fitness
        fitness_history.append(best_fitness)

    return best_solution, best_fitness, fitness_history

# Run experiments with different problem sizes
def run_experiments_with_problem_sizes(problem_sizes, pop_size, num_generations, mutation_rate, num_runs, seeds):
    avg_fitness_per_size = []
    fitness_results_per_size = []

    for size in problem_sizes:
        fitness_results = []
        for seed in seeds:
            weights, values, capacity = create_knapsack_problem(size)
            _, best_fitness, _ = genetic_algorithm_knapsack(weights, values, capacity, pop_size, num_generations, mutation_rate, seed)
            fitness_results.append(best_fitness)
        avg_fitness_per_size.append(np.mean(fitness_results))
        fitness_results_per_size.append(fitness_results)

    return avg_fitness_per_size, fitness_results_per_size

# Plot fitness vs. problem size
def plot_fitness_vs_problem_size(problem_sizes, avg_fitness_per_size):
    plt.figure(figsize=(10, 6))
    plt.plot(problem_sizes, avg_fitness_per_size, marker='o')
    plt.xlabel('Problem Size (Number of Items)')
    plt.ylabel('Fitness (Total Value)')
    plt.title('Fitness vs. Problem Size for Genetic Algorithm (Knapsack Problem)')
    plt.grid(True)
    plt.show()

# Parameters for Genetic Algorithm
problem_sizes = [10, 100, 1000, 5000]  # Different problem sizes
pop_size = 100  # Population size
num_generations = 100  # Number of generations
mutation_rate = 0.01  # Mutation rate
num_runs = 10  # Number of runs
seeds = [i for i in range(num_runs)]  # Generate N seeds

# Run experiments
avg_fitness_per_size, fitness_results_per_size = run_experiments_with_problem_sizes(problem_sizes, pop_size, num_generations, mutation_rate, num_runs, seeds)

# Plot fitness vs. problem size
plot_fitness_vs_problem_size(problem_sizes, avg_fitness_per_size)

# Display fitness results in a table
fitness_results_df = pd.DataFrame(fitness_results_per_size, index=problem_sizes).T
fitness_results_df.columns = [f'Problem Size {size}' for size in problem_sizes]
fitness_results_df.index.name = 'Run'
print(fitness_results_df)

import matplotlib.pyplot as plt
import mlrose_hiive as mlrose

# Data
problem_sizes = [10, 100, 1000, 5000]
rhc_fitness = [0, 3633, 28886, 132339]
sa_fitness = [234, 3202, 27274, 132704]
ga_fitness = [345, 3199, 27248, 131838]

# Plot
plt.figure(figsize=(10, 6))
plt.plot(problem_sizes, rhc_fitness, marker='o', label='RHC')
plt.plot(problem_sizes, sa_fitness, marker='o', label='SA')
plt.plot(problem_sizes, ga_fitness, marker='o', label='GA')
plt.xlabel('Problem Size (Number of Items)')
plt.ylabel('Fitness (Total Value)')
plt.title('Fitness vs. Problem Size for Knapsack Problem')
plt.legend()
plt.grid(True)
plt.show()

import numpy as np
import random
import time
import matplotlib.pyplot as plt
import mlrose_hiive as mlrose

# Define the Knapsack problem
def create_knapsack_problem(num_items, max_weight):
    np.random.seed(42)
    weights = np.random.randint(1, 10, size=num_items)
    values = np.random.randint(1, 20, size=num_items)
    return weights, values, max_weight

# Define the fitness function for the Knapsack problem
def knapsack_fitness(solution, weights, values, max_weight):
    total_weight = np.sum(solution * weights)
    total_value = np.sum(solution * values)
    if total_weight > max_weight:
        return 0
    else:
        return total_value

# Swap two items in the solution
def flip_bit(solution):
    new_solution = solution.copy()
    i = random.randint(0, len(solution) - 1)
    new_solution[i] = 1 - new_solution[i]
    return new_solution

# Randomized Hill Climbing algorithm for Knapsack problem
def randomized_hill_climbing_knapsack(weights, values, max_weight, max_iterations, seed):
    np.random.seed(seed)
    random.seed(seed)

    num_items = len(weights)
    current_solution = np.random.randint(2, size=num_items)
    current_fitness = knapsack_fitness(current_solution, weights, values, max_weight)

    fitness_history = [current_fitness]

    for _ in range(max_iterations):
        new_solution = flip_bit(current_solution)
        new_fitness = knapsack_fitness(new_solution, weights, values, max_weight)

        if new_fitness > current_fitness:
            current_solution = new_solution
            current_fitness = new_fitness

        fitness_history.append(current_fitness)

    return current_solution, current_fitness, fitness_history

# Run experiments with different problem sizes
def run_experiments_with_times_knapsack(problem_sizes, max_iterations, num_runs, seeds, max_weight):
    avg_times_per_size = []

    for size in problem_sizes:
        total_time = 0
        for seed in seeds:
            weights, values, max_weight = create_knapsack_problem(size, max_weight)
            start_time = time.time()
            randomized_hill_climbing_knapsack(weights, values, max_weight, max_iterations, seed)
            end_time = time.time()
            total_time += (end_time - start_time)
        avg_time = total_time / num_runs
        avg_times_per_size.append(avg_time)

    return avg_times_per_size

# Plot wall clock time vs. problem size
def plot_times_vs_problem_size(problem_sizes, avg_times_per_size):
    plt.figure(figsize=(10, 6))
    plt.plot(problem_sizes, avg_times_per_size, marker='o')
    plt.xlabel('Problem Size (Number of Items)')
    plt.ylabel('Average Wall Clock Time (seconds)')
    plt.title('Wall Clock Time vs. Problem Size for Randomized Hill Climbing (Knapsack Problem)')
    plt.grid(True)
    plt.show()

# Parameters for Randomized Hill Climbing
problem_sizes = [100,1000,5000]  # Different problem sizes
max_iterations = 1000  # Maximum number of iterations
num_runs = 10  # Number of runs
seeds = [i for i in range(num_runs)]  # Generate N seeds
max_weight = 50  # Maximum weight for the knapsack

# Run experiments
avg_times_per_size = run_experiments_with_times_knapsack(problem_sizes, max_iterations, num_runs, seeds, max_weight)

# Plot wall clock time vs. problem size
plot_times_vs_problem_size(problem_sizes, avg_times_per_size)

# Display the average times
for size, time_taken in zip(problem_sizes, avg_times_per_size):
    print(f'Average wall clock time for problem size {size}: {time_taken:.4f} seconds')

import numpy as np
import random
import time
import matplotlib.pyplot as plt
import mlrose_hiive as mlrose

# Define the Knapsack problem
def create_knapsack_problem(num_items, max_weight):
    np.random.seed(42)
    weights = np.random.randint(1, 10, size=num_items)
    values = np.random.randint(1, 20, size=num_items)
    return weights, values, max_weight

# Define the fitness function for the Knapsack problem
def knapsack_fitness(solution, weights, values, max_weight):
    total_weight = np.sum(solution * weights)
    total_value = np.sum(solution * values)
    if total_weight > max_weight:
        return 0
    else:
        return total_value

# Swap two items in the solution
def flip_bit(solution):
    new_solution = solution.copy()
    i = random.randint(0, len(solution) - 1)
    new_solution[i] = 1 - new_solution[i]
    return new_solution

# Simulated Annealing algorithm for Knapsack problem
def simulated_annealing_knapsack(weights, values, max_weight, max_iterations, seed, initial_temp, cooling_rate):
    np.random.seed(seed)
    random.seed(seed)

    num_items = len(weights)
    current_solution = np.random.randint(2, size=num_items)
    current_fitness = knapsack_fitness(current_solution, weights, values, max_weight)
    best_solution = current_solution
    best_fitness = current_fitness

    fitness_history = [current_fitness]
    temperature = initial_temp

    for _ in range(max_iterations):
        new_solution = flip_bit(current_solution)
        new_fitness = knapsack_fitness(new_solution, weights, values, max_weight)
        delta_fitness = new_fitness - current_fitness

        if delta_fitness > 0 or random.random() < np.exp(delta_fitness / temperature):
            current_solution = new_solution
            current_fitness = new_fitness

            if new_fitness > best_fitness:
                best_solution = new_solution
                best_fitness = new_fitness

        fitness_history.append(current_fitness)
        temperature *= cooling_rate

    return best_solution, best_fitness, fitness_history

# Run experiments with different problem sizes
def run_experiments_with_times_knapsack_sa(problem_sizes, max_iterations, num_runs, seeds, max_weight, initial_temp, cooling_rate):
    avg_times_per_size = []

    for size in problem_sizes:
        total_time = 0
        for seed in seeds:
            weights, values, max_weight = create_knapsack_problem(size, max_weight)
            start_time = time.time()
            simulated_annealing_knapsack(weights, values, max_weight, max_iterations, seed, initial_temp, cooling_rate)
            end_time = time.time()
            total_time += (end_time - start_time)
        avg_time = total_time / num_runs
        avg_times_per_size.append(avg_time)

    return avg_times_per_size

# Plot wall clock time vs. problem size
def plot_times_vs_problem_size(problem_sizes, avg_times_per_size):
    plt.figure(figsize=(10, 6))
    plt.plot(problem_sizes, avg_times_per_size, marker='o')
    plt.xlabel('Problem Size (Number of Items)')
    plt.ylabel('Average Wall Clock Time (seconds)')
    plt.title('Wall Clock Time vs. Problem Size for Simulated Annealing (Knapsack Problem)')
    plt.grid(True)
    plt.show()

# Parameters for Simulated Annealing
problem_sizes = [100, 1000, 5000]  # Different problem sizes
max_iterations = 1000  # Maximum number of iterations
num_runs = 10  # Number of runs
seeds = [i for i in range(num_runs)]  # Generate N seeds
max_weight = 50  # Maximum weight for the knapsack
initial_temp = 1000  # Initial temperature
cooling_rate = 0.995  # Cooling rate

# Run experiments
avg_times_per_size = run_experiments_with_times_knapsack_sa(problem_sizes, max_iterations, num_runs, seeds, max_weight, initial_temp, cooling_rate)

# Plot wall clock time vs. problem size
plot_times_vs_problem_size(problem_sizes, avg_times_per_size)

# Display the average times
for size, time_taken in zip(problem_sizes, avg_times_per_size):
    print(f'Average wall clock time for problem size {size}: {time_taken:.4f} seconds')

import numpy as np
import random
import time
import matplotlib.pyplot as plt
import mlrose_hiive as mlrose

# Define the Knapsack problem
def create_knapsack_problem(num_items, max_weight):
    np.random.seed(42)
    weights = np.random.randint(1, 10, size=num_items)
    values = np.random.randint(1, 20, size=num_items)
    return weights, values, max_weight

# Define the fitness function for the Knapsack problem
def knapsack_fitness(solution, weights, values, max_weight):
    total_weight = np.sum(solution * weights)
    total_value = np.sum(solution * values)
    if total_weight > max_weight:
        return 0
    else:
        return total_value

# Create an initial population
def create_population(pop_size, num_items):
    population = []
    for _ in range(pop_size):
        solution = np.random.randint(2, size=num_items)
        population.append(solution)
    return population

# Select parents based on fitness
def select_parents(population, weights, values, max_weight):
    fitness_scores = [knapsack_fitness(solution, weights, values, max_weight) for solution in population]
    total_fitness = sum(fitness_scores)
    if total_fitness == 0:
        selection_probs = [1 / len(fitness_scores)] * len(fitness_scores)
    else:
        selection_probs = [score / total_fitness for score in fitness_scores]
    parents = random.choices(population, weights=selection_probs, k=len(population))
    return parents

# Perform crossover between two parents to produce offspring
def crossover(parent1, parent2):
    size = len(parent1)
    start, end = sorted(random.sample(range(size), 2))
    child = np.zeros(size, dtype=int)
    child[start:end] = parent1[start:end]
    fill_idx = end
    for gene in parent2:
        if gene not in child[start:end]:
            while child[fill_idx] != 0:
                fill_idx = (fill_idx + 1) % size
            child[fill_idx] = gene
    return child

# Perform mutation on a solution
def mutate(solution, mutation_rate):
    for i in range(len(solution)):
        if random.random() < mutation_rate:
            solution[i] = 1 - solution[i]
    return solution

# Genetic Algorithm for Knapsack problem
def genetic_algorithm_knapsack(weights, values, max_weight, pop_size, num_generations, mutation_rate, seed):
    np.random.seed(seed)
    random.seed(seed)

    num_items = len(weights)
    population = create_population(pop_size, num_items)
    best_solution = max(population, key=lambda solution: knapsack_fitness(solution, weights, values, max_weight))
    best_fitness = knapsack_fitness(best_solution, weights, values, max_weight)

    fitness_history = [best_fitness]

    for _ in range(num_generations):
        parents = select_parents(population, weights, values, max_weight)
        population = [mutate(crossover(parents[i], parents[len(parents) - i - 1]), mutation_rate) for i in range(len(parents))]
        current_best_solution = max(population, key=lambda solution: knapsack_fitness(solution, weights, values, max_weight))
        current_best_fitness = knapsack_fitness(current_best_solution, weights, values, max_weight)
        if current_best_fitness > best_fitness:
            best_solution = current_best_solution
            best_fitness = current_best_fitness
        fitness_history.append(best_fitness)

    return best_solution, best_fitness, fitness_history

# Run experiments with different problem sizes
def run_experiments_with_times_knapsack_ga(problem_sizes, pop_size, num_generations, mutation_rate, num_runs, seeds, max_weight):
    avg_times_per_size = []

    for size in problem_sizes:
        total_time = 0
        for seed in seeds:
            weights, values, max_weight = create_knapsack_problem(size, max_weight)
            start_time = time.time()
            genetic_algorithm_knapsack(weights, values, max_weight, pop_size, num_generations, mutation_rate, seed)
            end_time = time.time()
            total_time += (end_time - start_time)
        avg_time = total_time / num_runs
        avg_times_per_size.append(avg_time)

    return avg_times_per_size

# Plot wall clock time vs. problem size
def plot_times_vs_problem_size(problem_sizes, avg_times_per_size):
    plt.figure(figsize=(10, 6))
    plt.plot(problem_sizes, avg_times_per_size, marker='o')
    plt.xlabel('Problem Size (Number of Items)')
    plt.ylabel('Average Wall Clock Time (seconds)')
    plt.title('Wall Clock Time vs. Problem Size for Genetic Algorithm (Knapsack Problem)')
    plt.grid(True)
    plt.show()

# Parameters for Genetic Algorithm
problem_sizes = [100,1000,5000]  # Different problem sizes
pop_size = 100  # Population size
num_generations = 100  # Number of generations
mutation_rate = 0.01  # Mutation rate
num_runs = 10  # Number of runs
seeds = [i for i in range(num_runs)]  # Generate N seeds
max_weight = 50  # Maximum weight for the knapsack

# Run experiments
avg_times_per_size = run_experiments_with_times_knapsack_ga(problem_sizes, pop_size, num_generations, mutation_rate, num_runs, seeds, max_weight)

# Plot wall clock time vs. problem size
plot_times_vs_problem_size(problem_sizes, avg_times_per_size)

# Display the average times
for size, time_taken in zip(problem_sizes, avg_times_per_size):
    print(f'Average wall clock time for problem size {size}: {time_taken:.4f} seconds')